\chapter*{Commander X16 BASIC}
\addcontentsline{toc}{chapter}{\protect\numberline{}Commander X16 BASIC}

This manual has introduced you to the BASIC language and many of the commands,
operators, and conventions.  However, that is not enough in order to truly
understand how to use BASIC.  This appendix is a reference that aims to provide
a complete documentation for Commander X16 BASIC.  It will provide the rules
(known as \emph{syntax}) of the BASIC language, and concise descriptions of
each BASIC command.\\

To make this information easier to read, it is broken up into the following
sections:\\

\begin{enumerate}

	\item {\bfseries Variables}: describes what variables are, the different
		types of variables, and the allowed variable names.

	\item {\bfseries Operators}: describes arithmetic and logical operators.

	\item {\bfseries Commands}: describes the interactive commands that are
		used to work with programs or perform other tasks that users typically
		type directly into the {\ttfamily READY} prompt.

	\item {\bfseries Statements}: describes the statements that are typically
		used in BASIC programs, but aren't often called directly by users from
		the {\ttfamily READY} prompt.

	\item {\bfseries Functions}: describes the BASIC functions that return
		values, such as calculations and string operations.

	\item {\bfseries System Variables}: describes the special purpose variables
		that are available in every BASIC program.

\end{enumerate}

\vspace{16pt}

\note{

	Commands and statements are not technically different, and often these
	terms are used interchangeably.  Commands can be used from within BASIC
	programs and statements can be run directly from the {\ttfamily READY}
	prompt.  The reason for different labels is because many commands make
	little sense when used from within BASIC programs.  For example, using the
	{\ttfamily NEW} command inside a BASIC program will cause the program to
	halt execution and be removed from memory!

}

\section{Variables}

Variables are values that have been given names.  Programs use variables for
many purposes, and they are an important part of BASIC programming.
Programmers can \emph{assign} a value to a variable, and then use that value
later in their program by referring to the variable.  For example:\\

\codeblock{
	10 T\$ = "X16"\\
	20 PRINT T\$\\
}

The above BASIC program stores the value {\ttfamily "X16"} in a variable named
{\ttfamily T\$}, and then {\ttfamily PRINT}s the value of {\ttfamily T\$} to
the screen.\\

Variables are similar to memory addresses except for a couple of key
differences.  First, the programmer doesn't have to keep track of where a
variable is stored in the Commander X16's memory.  This job is performed by
BASIC to make the programmer's job easier.  Second, variables have a
\emph{type}.  There are three types of variables in Commander X16 BASIC.  The
three types of variables are: \emph{floating point}, \emph{integer numeric},
and \emph{string (alphanumeric)} variables.\\

\subsection{Floating Point Variables}

\emph{Floating point numeric variables} can have any value from $-10^{38}$ to
$10^{38}$, with up to nine digits of accuracy.  Floating point values can hold
partial values, such as $3.4$, $42.7$, or $0.000025$.  This makes them useful
for a variety of mathematical uses.  Floating point variables can be named with
any single letter, any letter followed by a number, or with two
letters\footnote{There are three variable names that are \emph{reserved} by the
Commander X16 for its own use, and cannot be used for variable names in your
programs.  These names are {\ttfamily MX},{\ttfamily MY},{\ttfamily MB},
{\ttfamily ST}, {\ttfamily TI}, {\ttfamily TI\$}, and {\ttfamily DA\$}.   See
the section on System Variables}.  For example, {\ttfamily A}, {\ttfamily A5},
or {\ttfamily AB}.\\

To assign a floating point variable, type your chosen name for the variable
followed by an {ttfamily =} and then the value you wish to assign it:\\

\codeblock{
	A = 3.4\\
	A5 = 42.7\\
	AB = 0.000025\\
}

For numbers that are very large or very small, you may wish to use scientific
notation to assign your variables.  The Commander X16 understands scientific
notation by using the letter {\ttfamily E} to separate the coefficient from the
exponent (the base is always assumed to be $10$).  So to assign the value $3.7
\times 10^{-14}$ to a floating point variable named {\ttfamily B2}, you would
type:\\

\codeblock{
	B2 = 3.7E-14\\
}

Not only can you assign floating point variables using scientific notation, but
the Commander X16 will also display values in scientific notation if they
require more than nine digits.\\

\subsection{Integer Variables}

\emph{Integer numeric variables} should be used whenever the number will always
be a whole number, and always be between $-32768$ and $32767$.  These are
numbers like $1$, $5$, or $-127$.  Integer variables take up less space in the
Commander X16's memory, and doing math with integers is faster than with
floating point numbers.  Integer numeric variables follow the same rules as
floating point variables, except they must have a {\ttfamily \%} character at
the end.  For example:\\

\codeblock{
	B\% = 5\\
	C5\% = -11\\
	BC\% = 1261\\
}

\note{

	Sometimes when writing numbers we place a {\ttfamily ,} to separate groups
	of three digits, such as $1,000$ or $8,006,029,545$.  While this makes
	numbers easier for humans to read, it is not something that Commander X16
	understands.  When typing numbers into your programs, you should never use
	a {\ttfamily ,} but instead type the numbers without it.  So the previous
	numbers would be typed as $1000$ and $8006029545$.\\

}

\subsection{String Variables}

\emph{String variables} are used to store characters, such as words, sentences,
or any other symbol that you can type.  A single string variable can store
either a single character, many characters in a row, or even no characters at
all!String variable names follow the same rules as floating point variables,
except they must have a {\ttfamily \$} character at the end.  The value of a
string variable must be enclosed in quotation marks.  For example:\\

\codeblock{
	N\$ = "COMMANDER X16"\\
	B8\$ = "SEVEN"\\
	DC\$ = "THE NEXT STRING HAS NO CHARACTERS IN IT"\\
	EC\$ = ""\\
}

\subsection{Arrays}

\emph{Arrays} are lists of variables that all share the same name.  You can
specify which item, or \emph{element}, in the list you are using by using a
number.  For example, if you have an array of floating point values in a
variable named {\ttfamily AB} you can use the second value in the array by
typing {\ttfamily AB(2)} where you would normally type a variable name or a
value.  You can create an array that holds any of the above types of variables,
but a single a array can only hold one type of variable.  So an array that was
created to hold seven strings can \emph{only} hold string variables, and will
cause an error if you try to assign an integer to one of the elements.\\

Unlike other variables, array variables usually\footnote{see the documentation
of the {\ttfamily DIM} statement for exceptions} need to be \emph{declared}
before using them.  You can declare your array variable with the {\ttfamily
DIM} statement like so:\\

\codeblock{
	DIM A(25)\\
}

This will tell the Commander X16 to reserve enough memory for twenty-five
floating point variables.  You can access these variables by \emph{indexing}
the array variable {\ttfamily A} when using it, like so:\\

\codeblock{
	PRINT A(14)\\
}

The above example prints the value of the fourteenth \emph{element} of
{\ttfamily A} to the screen.\\

Arrays can have more than one \emph{dimension} by declaring them with more than
one index.  For example a two-dimensional array can be useful for storing data
arranged as rows and columns.  Here is how you would declare an array with 24
rows of 32 columns:\\

\codeblock{
	DIM S\%(32,24)\\
}

The above array can store $32 \times 24$ integer values.  You could even
declare arrays with even higher dimensions if you have a need for it.  Be
warned, however, as higher dimensional arrays take up exponentially more memory
so you will quickly run out.\\

\section{Operators}

Commander X16 BASIC uses three different types of \emph{operators}:
\emph{arithmetic} operators, \emph{comparison} operators, and \emph{logical}
operators.

\subsection{Arithmetic Operators}

\emph{Arithmetic operators} are used for mathematical calculations.  Here are
the available arithmetic operators:\\

\begin{tabular}{l p{0.8\linewidth}}
	\ttfamily\bfseries{+}&addition\\
	\ttfamily\bfseries{-}&subtraction\\
	\ttfamily\bfseries{*}&multiplication\\
	\ttfamily\bfseries{/}&division\\
	\ttfamily\bfseries{↑}&raising to a power (exponentiation)\\
\end{tabular}

\vspace{16pt}

When several operators are used in the same arithmetic expression, there is an
\emph{order} in which the operations execute.  First, any exponentiation
operations execute.  Next, any multiplication or division operations execute.
Finally, any addition or subtraction operations execute.  When there are two or
more operations that execute at the same time, such as a multiplication
followed by a division, the operations execute from left to right.  Consider
the following:\\

\codeblock{
	PRINT 2/4/2\\
}

The above code will execute and print {\ttfamily .25} to the screen instead of
printing {\ttfamily 1}.  This is because {\ttfamily 2/4} executes first to
produce {\ttfamily .5}, and then {\ttfamily .5/2} executes to produce a final
value of {\ttfamily .25}.  If desired, you can force the order of operations by
enclosing calculations inside parentheses.  For example, we could reverse the
order of the operations above by typing:\\

\codeblock{
	PRINT 2/(4/2)\\
}

Now the result is {\ttfamily 1} because {\ttfamily 4/2} is executed first to
produce {\ttfamily 2}, and then {\ttfamily 2/2} executes to produce {\ttfamily
1}.

Using parentheses is a good practice even when not necessary, because it makes
the intention of the calculation obvious when reading the code.  Had we used
them in the original example, it would have made the execution obvious at first
glance:\\

\codeblock{
	PRINT (2/4)/2\\
}

The above code is identical to {\ttfamily 2/4/2}, but is easier to read.

\subsection{Comparison Operators}

\emph{Comparison operators} are useful for determining equalities and
inequalities.  These are used comparing values against each other to determine
if they are the same, not the same, or which is larger.  The comparison
operators are:\\

\begin{tabular}{l p{0.8\linewidth}}
	\ttfamily\bfseries{=}&is equal to\\
	\ttfamily\bfseries{<}&is less than\\
	\ttfamily\bfseries{>}&is greater than\\
	\ttfamily\bfseries{<= or =<}&is less than or equal to\\
	\ttfamily\bfseries{>= or =>}&is greater than or equal to\\
	\ttfamily\bfseries{<> or ><}&is not equal to\\
\end{tabular}

\vspace{16pt}

Comparison operators are most often used with {\ttfamily IF...THEN} statements.
For example:\\

\codeblock{
	A = 12\\
	IF A > 10 THEN PRINT "GREATER THAN 10"\\
}

As you can see from the code above, both variables and literal values can be
used with comparison operators.\\

\subsection{Logical Operators}

\emph{Logical operators} are used to join together multiple comparison
statements into a single statement.  There are three logical operators:\\

\begin{tabular}{l p{0.8\linewidth}}
	\ttfamily\bfseries{AND}&is true if both the left side and the right side are true\\
	\ttfamily\bfseries{OR}&is true if either the left side or the right side are true\\
	\ttfamily\bfseries{NOT}&is true if the right side is false\\
\end{tabular}

\vspace{16pt}

By using these logical operators, you can write complex conditions for your
programs.  Here's some examples:\\

\codeblock{
	IF A = B AND C = D THEN 100\\
	IF A = B OR NOT (C = D) THEN 100\\
}

Notice how parentheses can be used to explicitly force the order in which
logical conditions are evaluated, just like how they force the order in which
arithmetic is evaluated.\\

\section{Commands}

\emph{Commands} are instructions that you type in order to work with programs
on the Commander X16 or perform other user tasks.  Commands tell the Commander
X16 to do things, such as {\ttfamily LIST} the contents of the SD card,
{\ttfamily LOAD} a program from the SD card, or {\ttfamily RUN} the currently
loaded program.  This section contains a description of each command in
alphabetical order.\\

\subsection{BANNER}

The {\ttfamily BANNER} command displays the Commander X16 logo and boot text,
like is automatically displayed upon boot.

\subsection{BOOT}

The {\ttfamily BOOT} command loads and runs a PRG file named {\ttfamily
AUTOBOOT.X16} from device \#8 (the SD card reader). If the file is not found,
nothing is done and no error is printed.\\

\subsection{CLR}

The {\ttfamily CLR} command clears the BASIC variables from memory.  This
includes variables that were assigned values while running BASIC programs as
well as any BASIC assignments that were called from the {\ttfamily READY}
prompt directly.  Variables cleared with {\ttfamily CLR} cannot be restored
with the {\ttfamily OLD} command.

The {\ttfamily CLR} command runs automatically whenever the {\ttfamily RUN}
command is called, so that each run of a program starts with a cleared
variables state.  {\ttfamily CLR} is \emph{not} called when the {\ttfamily
CONT} command is run, so that a prgram can continue where it left off with the
variable state in tact.\\

\subsection{CLS}

The {\ttfamily CLS} command clears the screen. This has the same effect as
typing {\ttfamily PRINT CHR\$(147);} or typing
\keybackgroundcolor{gray}\keytextcolor{black}\widekey{shift}+\doublekey{clr\\home}.
This command is useful when programs and commands have cluttered up the screen,
and is also useful in BASIC programs to {\ttfamily PRINT}ing to an empty
screen.\\

\subsection{CONT (continue)}

When a program has been stopped by either using the
\keybackgroundcolor{gray}\doublekey{RUN\\STOP} key, a {\ttfamily STOP}
statement, or an {\ttfamily END} statement within the program, it can be
restarted by using the {\ttfamily CONT} command.  The {\ttfamily CONT} command
will continue executing the loaded program at the exact place from which it
left off, with all the variables intact.\\

The {\ttfamily CONT} command will not always work, however.  If you make any
modifications to your program while it is stopped, the {\ttfamily CONT} command
will fail and display a {\ttfamily CAN'T CONTINUE ERROR}.  This is true even if
you {\ttfamily LIST} the program and hit \widekey{RETURN} while the cursor is
on a line of the program...even if you didn't make any modifications.  To the
X16, this is still considered a change to the program, so the only way to run
it again is to start at the beginning of the program by using the {\ttfamily
RUN} command.\\

\subsection{DOS}

This command works with the command/status channel or the directory of a
Commodore DOS device and has different functionality depending on the type of
argument.\\

\begin{itemize}

	\item Without an argument, DOS prints the status string of the current device.

	\item With a string argument of {\ttfamily "8"} or {\ttfamily "9"}, it
		switches the current device to the given number.

	\item With an argument starting with {\ttfamily "\$"}, it shows the
		directory of the device.

	\item Any other argument will be sent as a DOS command.

\end{itemize}

\vspace{16pt}

Examples:\\

\codeblock{
	DOS"\$"          : REM SHOWS DIRECTORY\\
	DOS"S:BAD\_FILE" : REM DELETES "BAD\_FILE"\\
	DOS             : REM PRINTS DOS STATUS\\
}

\subsection{HELP}

The {\ttfamily HELP} command displays a brief summary of the current ROM build,
VERA version, and PS/2 microcontroller code version.  It also displays some
URLs for documentation and community support.  All of this information could be
useful in troubleshooting issues the Commander X16.\\


\subsection{KEYMAP}

The {\ttfamily KEYMAP} command sets the current keyboard layout. It can be put
into an {\ttfamily AUTOBOOT.X16} file to always set the keyboard layout on
boot.\\

Example:\\

\codeblock{
	10 REM PROGRAM TO SET LAYOUT TO SWEDISH/SWEDEN\\
	20 KEYMAP "SV-SE"\\
	SAVE"AUTOBOOT.X16"  :REM SAVE AS AUTOBOOT FILE\\
}

\subsection{LIST}

The {\ttfamily LIST} command will print the currently loaded BASIC program to
the screen, either in its entirety or only the parts specified by the user.
When {\ttfamily LIST} is used without any numbers typed after it (known as
\emph{arguments}), you will see a complete listing of the program on your
screen.\\

A recent update to the {\ttfamily LIST} command allows the listing to be paused
by tapping the \widekey{SPACE} bar.  Otherwise, it continues to work as before.
This new feature works best with the cursor near the bottom of the screen as
the X16 listing will quickly scroll past the top of the screen.  Some practice
may be needed to effectively pause when needed.\\

While paused, it is possible to use \doublekey{Page\\Down} to show one page at a
time or the \widekey{↓} to advance one line at a time.  If the \widekey{SPACE} bar
is pressed in the paused state, listing will continue.  While paging, several
blank lines remain at the bottom of the screen for lengthy BASIC logical
lines.  Also, there is room for the {\ttfamily READY} prompt after tapping
the \doublekey{Pause\\Break} key while exiting the listing.  For single-line
stepping the entire screen is used.\\

If the program scrolls off the screen, and you are unable to see the
part that you want, you have a couple of options.  First, you can use the
\widekey{CTRL} key to slow down how fast lines are printed to the screen.  
Press \doublekey{Pause\\Break} to exit the listing at the appropriate location.
The part you wish to see will still scroll off eventually, but you will be given
a much longer time to look for it.  Second, you can use the {\ttfamily LIST}
command with arguments that will limit the listing to only the line or lines
that you wish to see.  When you follow the {\ttfamily LIST} command with a
single number, the X16 will list only that line number (if it exists).  If you
follow {\ttfamily LIST} with two line numbers separated by a dash, the X16 will
list all the lines from the first number to the second (including both line
numbers).  If you follow {\ttfamily LIST} with a dash followed by a single
number, it lists from the beginning of the program up to and including the line
number.  Finally, if you follow {\ttfamily LIST} with a number followed by a
dash, it lists from the line number until the end of the program.\\

Examples:\\

\begin{tabular}{l p{0.8\linewidth}}
	{\ttfamily\bfseries LIST}&Shows entire program.\\\\
	{\ttfamily\bfseries LIST 10-}&Shows only from line 10 through the end.\\\\
	{\ttfamily\bfseries LIST 10}&Shows only line 10.\\\\
	{\ttfamily\bfseries LIST -10}&Shows from the beginning through line 10.\\\\
	{\ttfamily\bfseries LIST 10-20}&Shows lines from 10 through 20.\\\\
\end{tabular}

\vspace{16pt}

\subsection{LOAD}

The {\ttfamily LOAD} command is used when you want to use a program that is
stored on the Commander X16's SD card\footnote{the {\ttfamily LOAD} command can
also be used with other devices, but only the SD card reader ships with the
Commander X16}.  Typing {\ttfamily LOAD} and hitting \widekey{Return} will find
the first program on the SD card\footnote{The SD card uses the FAT32 disk
format, so it's complicated what makes a file considered to be the "first".  It
is safer to specify the name of the file when possible} and bring it into
memory to be {\ttfamily RUN}, {\ttfamily LIST}ed, or edited.  You can also type
{\ttfamily LOAD} followed by a name of a file in quotes({\ttfamily ""}) to
specify which file to load into memory.  The file name argument may be followed
by a comma and a numeric value which specifies a device number.  If no number
is given, the X16 uses device \#8, which is the SD card reader.\\

Examples:\\

\begin{tabular}{l p{0.5\linewidth}}

	{\ttfamily\bfseries LOAD}&Loads the first program on the SD card into
	memory.\\\\

	{\ttfamily\bfseries LOAD "HELLO.PRG"}&Loads a program named {\ttfamily
	HELLO.PRG} from the SD card into memory.\\\\

	{\ttfamily\bfseries LOAD A\$}&Loads a program whose name is stored in the
	string variable {\ttfamily A\$} from the SD card into memory.\\\\

	{\ttfamily\bfseries LOAD "HELLO.PRG",9}&Loads a program named {\ttfamily
	HELLO.PRG} from the drive configured as device \#9.\\\\

\end{tabular}

\vspace{16pt}

There are also special file names that can be loaded that perform specific
tasks when used with {\ttfamily LOAD}:\\

\begin{tabular}{l p{0.75\linewidth}}

	{\ttfamily\bfseries LOAD "*",8}&Loads the first program on device \#8 into
	memory.\\\\

	{\ttfamily\bfseries LOAD "\$"}&Loads a directory listing of the SD card
	into memory which can be displayed with {\ttfamily LIST}.\\\\

\end{tabular}

\vspace{16pt}

The {\ttfamily LOAD} command can be used with a BASIC program to load and
{\ttfamily RUN} another program.\\

\subsection{MENU}

The {\ttfamily MENU} command presents the user with a menu of built-in programs
stored in the X16's ROM.  The user can then select a program to run, or return
to BASIC.\\

\subsection{MON}

The {\ttfamily MON} command causes the Commander X16 to enter the machine
language monitor.\\

\subsection{NEW} 

The {\ttfamily NEW} command marks the current program and its variables as
erased, but leaves them in memory.  This behavior is so that both the program
and its variables can be restored with the {\ttfamily OLD} command.  The effect
is that the Commander X16 is ready for a new program.\\

\subsection{OLD}

 The {\ttfamily OLD} command recovers the BASIC program in RAM that has been
 previously marked erased either by using the {\ttfamily NEW} command, by
 pressing the reset button on the case, or by pressing the
 \keybackgroundcolor{gray}\keytextcolor{black}\widekey{ctrl}+\widekey{alt}+\widekey{del}
 key combination on the keyboard.\\

\subsection{POWEROFF}

The {\ttfamily POWEROFF} command turns off the Commander X16.  It is equivalent
to pressing the Power button on the motherboard or case.\\

\subsection{REBOOT}

The {\ttfamily REBOOT} command performs a software reset of the system by
calling the ROM reset vector.  This performs all the boot routines in the
system ROM, but does not force the hardware to reset.  The {\ttfamily REBOOT}
command {\em does not} clear memory, but {\em does} clear any BASIC program
that is loaded.  Because it is still in memory, however, a previously loaded
BASIC program can be re-loaded by using the {\ttfamily OLD} command after a
reboot:\\

\screenbox{2.75in}{2in}{
	NEW\\
	10 PRINT "EXISTING PROGRAM"\\
	REBOOT\\
}
\screenbox{2.75in}{2in}{
	**** X16 BASIC ****\\
	512k HIGH RAM\\
	38655 BASIC BYTES FREE\\
	READY.\\
	OLD\\
	LIST\\
	10 PRINT "EXISTING PROGRAM"\\
	READY.\\
	\cursor
}

\subsection{REN}

The {\ttfamily REN} command renumbers a BASIC program while updating the line
number arguments of {\ttfamily GOSUB}, {\ttfamily GOTO}, {\ttfamily RESTORE},
{\ttfamily RUN}, and {\ttfamily THEN}.  The {\ttfamily REN} command takes three
optional arguments:\\

\begin{itemize}

	\item The line number of the first line after renumbering, default: {\ttfamily 10}

	\item The value of the increment of subsequent lines, default: {\ttfamily 10}

	\item The ealiest old line to start renumbering, default: {\ttfamily 0}

\end{itemize}

\vspace{16pt}

Example:\\

\codeblock{
	10 PRINT "HELLO"\\
	15 PRINT "CLEAN"\\
	20 PRINT "THIS"\\
	40 PRINT "UP"\\
	REN 100,5\\\\
	LIST\\
	100 PRINT "HELLO"\\
	105 PRINT "CLEAN"\\
	110 PRINT "THIS"\\
	115 PRINT "UP"\\
}

\subsection{RESET}

The {\ttfamily RESET} command performs a full system reset, but does not clear
memory.  This means that a BASIC program and its variables can be restored
after a {\ttfamily RESET} by using the {\ttfamily OLD} command.  Unlike the
{\ttfamily REBOOT} command, this triggers the Commander X16's hardware reset
line, which may be used by expansion ports to reset custom hardware.\\

\note{

	There are multiple ways to reset a Commander X16, and each produces a
	slightly different result.\\

	The first is by using the
	\keybackgroundcolor{gray}\keytextcolor{black}\widekey{ctrl}+\widekey{alt}+\widekey{restore}
	key combination.  This halts the execution of any program, clears the
	screen, and returns the user to the {\ttfamily READY} prompt.  It does not
	mark a program or its variables as erased, and so a program can be
	{\ttfamily RUN} again or {\ttfamily CONT}inued if desired.  This is
	equivalent to pressing the NMI button on the motherboard.\\

	The second is by using the {\ttfamily REBOOT} command.  This calls the
	initial boot up routines, clears any BASIC program, but does not clear the
	memory.  A previously loaded BASIC program can be restored with the
	{\ttfamily OLD} command.\\

	The third is by using the {\ttfamily RESET} command.  This is equivalent to
	pressing the reset button on the motherboard or pressing the
	\keybackgroundcolor{gray}\keytextcolor{black}\widekey{ctrl}+\widekey{alt}+\widekey{del}
	key combination.\\

	The fourth is a cold reboot, where the power to the Commander X16 is lost
	and then restored.  This causes the current program and its variables to be
	completely lost and they cannot be restored with the {\ttfamily OLD}
	command.  }

\subsection{RUN}

The {\ttfamily RUN} command executes the program currently loaded into memory.
This program could have been typed in, or it could have been loaded from the SD
card with the {\ttfamily LOAD} command.  When called, the {\ttfamily RUN}
command will clear the BASIC variables (just like calling the {\ttfamily CLR}
command) and begin running the program.  When no number follows the {\ttfamily
RUN} command, the program will start executing from the lowest line number in
the program.  Otherwise, {\ttfamily RUN} will start executing at the given line
number, or the next lowest line number in the program.\\

Examples:\\

\begin{tabular}{l p{0.75\linewidth}}

	{\ttfamily\bfseries RUN}&Starts program from lowest line number.\\\\

	{\ttfamily\bfseries RUN 50}&Starts program at line 50.\\\\

	{\ttfamily\bfseries RUN A}&UNDEFINED ERROR ({\ttfamily RUN} cannot be used
	with a variable to specify a line number).\\\\

\end{tabular}

\subsection{SAVE}

The {\ttfamily SAVE} command will store the the current program in memory to
the SD card or another storage device.  The {\ttfamily SAVE} command should be
followed either by a file name in quotation marks, or a string variable that
contains the desired file name\footnote{calling the {\ttfamily SAVE} command
without any arguments is technically allowed, but doesn't do anything.  On the
Commodore VIC-20 and Commodore 64 this was useful for saving the current
program to the current position of a tape drive with no name, but the Commander
X16's default device is an SD card reader where this concept makes no sense.
For historical reasons, the Commander X16 won't display an error if you run
{\ttfamily SAVE} with no arguments, but it also won't do anything}.  The file
name argument can be followed by a comma and a number or numeric variable.
This number tells the Commander X16 which device to store the file on.  Device
number 8 is the SD card drive and is used if no number is given.\\

If a tape dirve is used with the Commander X16, then a second numeric argument
of either {\ttfamily 0} or {\ttfamily 1} can be specified after the device
number.  If this second is a {\ttfamily 1}, an {\ttfamily END-OF-TAPE} marker
will be written after the program.  If you are attempting to {\ttfamily LOAD} a
program off a tape drive and this marker is read before finding the desired
file, a {\ttfamily FILE NOT FOUND ERROR} will be displayed.\\

Examples:\\

\begin{tabular}{l p{0.5\linewidth}}

	{\ttfamily\bfseries SAVE "HELLO.PRG"}&Saves the program in memory to a file
	on the SD card with the name {\ttfamily HELLO.PRG}.\\\\

	{\ttfamily\bfseries SAVE A\$}&Saves the program in memory to a file on the
	SD card the name contained in the variable{\ttfamily A\$}.\\\\

	{\ttfamily\bfseries SAVE "HELLO.PRG",1}&Saves the program in memory to a
	file on the drive configured as device \#1 with the name {\ttfamily
	HELLO.PRG}.\\\\

	{\ttfamily\bfseries SAVE "HELLO.PRG",1,1}&Saves the program in memory to a
	file on the drive configured as device \#1 with the name {\ttfamily
	HELLO.PRG} and writes an {\ttfamily END-OF-TAPE} marker after it.\\\\

\end{tabular}

\subsection{VERIFY}

The {\ttfamily VERIFY} command will compare the program in memory to a program
on the SD card or other storage device.  If the programs are the same, the
{\ttfamily VERIFY} command will display an {\ttfamily OK} message, and if they
differ it will display a {\ttfamily VERIFY ERROR} message.  This command helps
to ensure that a program is safely stored to the SD card or other storage
device before the user erases it from memory\footnote{this was far more useful
in the era or tape drives and floppy disks than it is on the Commander X16}.
When {\ttfamily VERIFY} is called without any arguments, it checks the program
in memory against the first file on the SD card\footnote{this is not
particularly useful, but is included behavior for historical reasons}.  When
called followed by a file name in quotation marks or a string variable
containing a file name, it compares the program in memory against the given
file.  Just like the {\ttfamily LOAD} and {\ttfamily SAVE} commands, the
{\ttfamily VERIFY} command can take a numeric second argument as a device
number.\\

% easter egg hidden here as a tribute to a VIC-20 User's Guide printing error
% https://cdn.discordapp.com/attachments/629903630916648962/1075543304680263710/20230215_162450.jpg
The {\ttfamily VERIFY} command can also be used if a tape drive is connected to
the Commander X16 as a storage device.  By {\ttfamily VERIFY}ing the last
program on the taþe, the position of the tape can be advanced to a safe section
to write over.  When {\ttfamily VERIFY} is complete, whether verification
succeeds or fails, the tape will be positioned at the next available space.\\

Examples:\\

\begin{tabular}{l p{0.5\linewidth}}

	{\ttfamily\bfseries VERIFY}&Checks the first program on the SD card.\\\\

	{\ttfamily\bfseries VERIFY A\$}&Checks the program with name in variable
	{\ttfamily A\$}.\\\\

	{\ttfamily\bfseries VERIFY "HELLO.PRG",1}&Checks the program on the drive
	configured as device \#1 with the name {\ttfamily HELLO.PRG}.\\\\

\end{tabular}

\section{Statements}

\emph{Statements} are the instructions used in BASIC on numbered lines of
programs.  They are used to define what it is that your program does.\\

\subsection{BANK}

The {\ttfamily BANK} statement sets which bank will be used when other commands
and statements interpret addresses in the \$A000 - \$FFFF range.  Because all
addresses from \$A000 and above are either banked "high" RAM or banked ROM,
certain commands need to know \emph{which} bank is being referred to.
Specifically, {\ttfamily SYS}, {\ttfamily POKE}, and {\ttfamily PEEK} all need
to know which bank to use when an address is given in the banked range.  The
{\ttfamily BANK} statement sets the bank for both banked RAM\footnote{RAM in
bank 0 is reserved for use by the KERNAL, so it is unwise to write values into
there} and banked ROM, although setting the banked ROM is optional.  The first
argument is used to set the RAM bank, and the optional second argument sets the
ROM bank.  To set a bank, call the {\ttfamily BANK} statement followed by a
numeric value from 0 through 255.\\

For example, to write some data into "high" RAM in bank 1:\\

\codeblock{
	10 BANK 1\\
	20 POKE \$A000,42\\
}

Then the bank can be switched, and the same address can be used to store more
data, without overwriting the data in bank 1:\\

\codeblock{
	30 BANK 2\\
	40 POKE \$A000,23\\
	50 BANK 1				REM SWITCH BACK TO BANK 1\\
	60 PRINT PEEK(\$A000)	REM PRINTS 42, NOT 23\\
}

The {\ttfamily BANK} statement also has some use as a command run from the
{\ttfamily READY} prompt.  It can be used to run programs that are shipped with
the Commander X16 in banked ROM.  For example, the CodeX16 Interactive Assembly
Environment in ROM bank 7 can by run by typing the following at the {\ttfamily
READY} prompt:\\

\codeblock{
	BANK 1,7\\
	SYS \$C000\\
}

\subsection{BINPUT\#}

 The {\ttfamily BINPUT\#} statement reads a block of data from an open file and
 stores the data into a string variable.  The {\ttfamily BINPUT\#} statement
 takes 3 arguments; the device number, the string variable to store the data
 into, and the number of bytes to read from the file.  If there are fewer bytes
 to be read than the specified number of bytes has been read, only the bytes
 available will be stored in the string variable.  If the end of the file is
 reached, the special variable {\ttfamily ST} will have its bit 6 set to
 {\ttfamily 1}.  This means {\ttfamily ST AND 64} will equal {\ttfamily TRUE}
 when {\ttfamily BINPUT\#} reads all the way to or past the end of the file.\\

 Example:\\

 \codeblock{

	 10 OPEN 8,8,8,"FILE.BIN,S,R"\\
	 20 BINPUT\# 8,A\$,5\\
	 30 PRINT "I GOT";LEN(A\$);"BYTES: ";A\$\\
	 40 IF ST AND 64 THEN 60 REM END OF FILE\\
	 50 GOTO 20\\
	 60 CLOSE 8\\
	 70 PRINT "FINISHED READING"\\

 }

\subsection{BLOAD}

The {\ttfamily BLOAD} statement loads a headerless\footnote{typically on
Commodore computers as well as the X16, files are expected to contain a
two-byte header that indicates an address where they are to be loaded into
memory.  A "headerless" file will not have those two bytes} file from a device
into banked RAM.  If the file is too large to fit within a bank, the {\ttfamily
BLOAD} statement will automatically continue writing the file to the next bank.
This allows file resources larger than 8 kilobytes to be used without the need
to break them up into smaller files.  This is useful for loading resources for
games and applications into "high" RAM that programs can then access during
execution.\\

Examples:\\

\begin{tabular}{l p{0.4\linewidth}}

	{\ttfamily\bfseries BLOAD "MYFILE.BIN",8,1,\$A000}&Loads a file named
	"MYFILE.BIN" from device 8 starting in bank 1 at \$A000.\\\\

	{\ttfamily\bfseries BLOAD "WHO.PCX",8,10,\$B000}&Loads a file named
	"WHO.PCX" from device 8 starting in bank 10 at \$B000.\\\\

\end{tabular}

\subsection{BVERIFY}

The {\ttfamily BVERIFY} statement compares a headerless file on the SD card or
other storage device to the contents of banked RAM.  As arguments, the
{\ttfamily BVERIFY} statement takes the name of the file, the device number,
the bank number, and the starting address within the bank.  If the file in
question extends past the end of the bank, the {\ttfamily BVERIFY} statement
will automatically continue checking on the file on the next bank, resetting
the address to {\ttfamily \$A000} as it changes the bank.  This allows it to be
used to verify files that are too large to fit inside a single bank of "high"
RAM.\\

Examples:\\

\begin{tabular}{l p{0.35\linewidth}}

	{\ttfamily\bfseries BVERIFY "MYFILE.BIN",8,1,\$A000}&Compares a file named
	"MYFILE.BIN" from device 8 against the RAM in bank 1 starting at
	\$A000.\\\\

	{\ttfamily\bfseries BVERIFY "WHO.PCX",8,10,\$B000}&Compares a file named
	"WHO.PCX" from device 8 against the RAM in bank 10 starting at \$B000.\\\\

\end{tabular}

\subsection{BVLOAD}

The {\ttfamily BVLOAD} statement loads a headerless file directly into the
VERA's VRAM.  For arguments, the {\ttfamily BVLOAD} statement takes the file's
name, the device number where the file is stored, the bank of VRAM on the VERA
(either {\ttfamily 0} or {\ttfamily 1}), and the address within the bank in
which to load.\\

Examples:\\

\begin{tabular}{l p{0.35\linewidth}}

	{\ttfamily\bfseries BVLOAD "MYFILE.BIN",8,0,\$4000}&Loads a file named
	"MYFILE.BIN" from device 8 into VRAM at address \$04000.\\\\

	{\ttfamily\bfseries BVLOAD "MYFONT.BIN",8,1,\$F000}&Loads a file named
	"MYFONT.BIN" from device 8 into VRAM at address \$1F000.\\\\

\end{tabular}

To load a file that has a two-byte header, see the {\ttfamily VLOAD} statement.\\

\subsection{CHAR}

The {\ttfamily CHAR} statement draws text to the screen at a given X,Y
coordinate and a given color.  The {\ttfamily CHAR} statement is only available
in graphics mode, and draws the text to the bitmap graphics layer instead of
the text layer.  Like other graphics mode statements, the {\ttfamily CHAR}
statement can draw in all 256 available colors.\\

\codeblock{

	10 SCREEN \$80\\
	20 CHAR 120,100,14,"COMMANDER"\\
	30 CHAR 180,100,2,"X16"\\
}

\subsection{CLOSE}

The {\ttfamily CLOSE} statement completes and closes any files used by
{\ttfamily OPEN} statements.  The {\ttfamily CLOSE} statement takes a single
argument that is the file number to be closed.\\

Examples:\\

\begin{tabular}{l p{0.35\linewidth}}

	{\ttfamily\bfseries CLOSE 0}&Close file 0\\\\

	{\ttfamily\bfseries CLOSE 4}&Close file 4\\\\

\end{tabular}

\subsection{CMD}

The {\ttfamily CMD} statement is used to send output that would normally go to
the screen to some other device instead.  The other device could be a file on
the SD card, a file on a disk or tape drive, a printer, a modem, or any other
device supported by the Commander X16.  The device must first be opened with
the {\ttfamily OPEN} statement followed by a numerical value that will be used
to reference the file or device.\\

Example:\\

\begin{tabular}{l p{0.45\linewidth}}

	{\ttfamily\bfseries OPEN 1,8,8,"NEWFILE,S,W"}&OPEN a file named {\ttfamily NEWFIL} on the SD card\\\\

	{\ttfamily\bfseries CMD 1}& All normal output now goes to a file named {\ttfamily NEWFILE}\\\\

	{\ttfamily\bfseries LIST}&The {\ttfamily LIST}ing goes to the file, not the screen -- even the word {\ttfamily LIST}\\\\

	{\ttfamily\bfseries PRINT\# 1}&Direct the output back to the screen before closing the device\\\\

	{\ttfamily\bfseries CLOSE 1}&Close file 1\\\\
	

\end{tabular}

If a BASIC error occurs the data ouput is switched back to the screen, with the
side effect that space characters will be send to the logical file of the
selected device.  This is why the {\ttfamily PRINT\#} statement should be used
prior to closing the device.\\

\subsection{COLOR}

The {\ttfamily COLOR} statement sets the text mode foreground color, and
optionally the background color.  It takes either one or two arguments, both
are integers from 0 through 15.  The first argument sets the color of the text,
and the optional second argument sets the background color.  The numbers given
correspond to the first 16 colors of the VERA's palette\footnote{If the VERA's
palette has been modified, then the modified colors are used.  The {\ttfamily
COLOR} statement will not restore the default VERA palette}.\\

Examples:\\

\begin{tabular}{l p{0.75\linewidth}}

	{\ttfamily\bfseries COLOR 2}&Set the text color to red.\\\\

	{\ttfamily\bfseries COLOR 5,0}&Set the text color to green and the
	background color to black.\\\\

\end{tabular}

The {\ttfamily COLOR} statement only effects areas of the screen where new text
is placed, and will not change existing characters.  This makes it convenient
to use in programs for drawing diagrams and images with PETSCII characters,
since you can change both foreground and background colors for each individual
charater.\\

\subsection{DATA}

The {\ttfamily DATA} statement creates a data section of a BASIC program from
which the {\ttfamily READ} statement will read from.  The {\ttfamily DATA}
statement is followed by a comma-separated list of values.  These values can be
integers, floating point numbers, or strings\footnote{String values can be
specified with or without quotation marks, unless they contain a space, comma,
or colon.  Despite this flexibility, it is best practice to always use
quotation marks for string data}.  It is important to use the correct variable
type when {\ttfamily READ}ing these values, otherwise a {\ttfamily TYPE
MISMATCH} error can occur.  If two commas have nothing between them, the value
will be interpreted as a {\ttfamily 0} for a number or an empty string.\\

Multiple {\ttfamily DATA} statements can be used in a program, and when one has
been completely read by enough {\ttfamily READ} statements, the next {\ttfamily
READ} statement will read from the next {\ttfamily DATA} statement.  All
{\ttfamily READ} statements in a program can be thought of as a single
contiguous block of data, even if the statements are not grouped together in
the program.\\

Examples:\\

\codeblock{
	10 READ A\\
	20 READ B\%\\
	30 READ C\$\\
	40 PRINT A, B\%,C\$\\
	50 DATA 34.2,42\\
	60 DATA "COMMANDER X16"\\
}

{\ttfamily DATA} statements do not need to be executed, so they can slow down a
program if placed before code does need to execute.  Because of this, it is
best to place all {\ttfamily DATA} statements at the end of program.\\

\subsection{DEF}

The {\ttfamily DEF} statement defines a calculation as a named function that
can be called by BASIC later.  This is useful for complex calculations that a
program does multiple times.  The {\ttfamily DEF} statement is followed by the
function name, which must be {\ttfamily FN} followed by one or two other
characters that make up a legal variable name.  This name is followed by a set
of parentheses enclosing a legal numeric variable name.  This is followed by an
equals sign and the formula you want to define, using the variable in the
parentheses like any other variable would be used.\\

Examples:\\

\codeblock{
	10 DEF FNC(R)=2*R*π : REM CIRCUMFERENCE OF  A CIRCLE\\
	20 DEF FNA(R)=π*(R↑2) : REM AREA OF  A CIRCLE\\
	30 PRINT "CIRCUMFERENCE:", FNC(10)\\
	40 PRINT "AREA:", FNA(10)\\
}

Only a single variable can be defined as an argument to a function.  The
{\ttfamily DEF} statement can only be used in a BASIC program (entered with a
line number), but the defined function can be used anywhere a BASIC function
can normally be used.\\

\note {

	The π character represents the number PI and is entered by pressing
	\keybackgroundcolor{gray}\keytextcolor{black}\widekey{shift} +
	\keybackgroundcolor{white}\key{\petsciifont ←} on the keyboard. If you are
	not using an official Commander X16 keyboard, then you would need to press
	\keybackgroundcolor{gray}\widekey{shift} +
	\keybackgroundcolor{white}\doublekey{\textasciitilde\\`} instead.

}

\subsection{DIM}

The {\ttfamily DIM} statement is used to \emph{dimension} an array, which means
to allocate enough space for the data the array will hold.  An array variable
needs to be {\ttfamily DIM}'d before using it unless it will only hold eleven
or fewer elements.  In all other cases, the {\ttfamily DIM} statement must be
used.\\

To dimension an array variable, use {\ttfamily DIM} followed by the variable
name.  Then, the size of each dimension of the array should be given, separated
by commas and surrounded by parentheses.  An array can have one or more
dimensions, and each dimension can be as large as needed\footnote{as long as
all the elements fit into memory}.  The total number of elements in an array
can be calculated by multiplying the size of each of the array's dimensions.
The {\ttfamily DIM} statement can dimension multiple arrays at once by
separating each array with a comma.\\

Examples:\\

\begin{tabular}{l p{0.55\linewidth}}

	{\ttfamily\bfseries DIM A(16)}&An array of 16 numbers.\\\\

	{\ttfamily\bfseries DIM B\$(26),C\%(13)}&An array of 26 strings and an
	array of 13 integers.\\\\

	{\ttfamily\bfseries DIM D(32,4,4)}&A 3-dimensional array of numbers where
	the dimensions are 32, 4, and 4.\\\\

\end{tabular}

Once dimensioned, arrays can be used just like other variables, except that the
index into each dimension must be specified:\\

\codeblock{
	10 DIM A\$(3,12)\\
	20 A\$(1,1) = "ONE"\\
	30 A\$(2,6) = "TWO"\\
	40 PRINT A\$(1,1) : REM PRINTS "ONE"\\
	50 PRINT A\$(2,6) : REM PRINTS "TWO"\\
	60 PRINT A\$(1,6) : REM PRINTS NOTHING\\
}

Executing a {\ttfamily DIM} statement on the same array more than once will
cause an error.  It is a best practice to keep all the {\ttfamily DIM}
statements towards the beginning of a program.\\

\subsection{END}

The {\ttfamily END} statement will stop a running program just as if it had run
out of lines.  The {\ttfamily CONT} command can then be used to start the
program again, starting from the line after the {\ttfamily END} statement.  In
this way, the {\ttfamily END} statement can be used to "pause" a program and
allow the user to perform other tasks before {\ttfamily CONT}inuing on with the
rest of the program.  For details about the limitations of {\ttfamily
CONT}inuing a program, see the documentation for the {\ttfamily CONT}
command.\\

\subsection{FMCHORD}

The {\ttfamily FMCHORD} statement instructs the FM synthesis chip to begin
playing multiple notes at the same time.  For arguments, the {\ttfamily
FMCHORD} statement accepts a channel and a string.  Because a chord plays
multiple notes at the same time, the channel argument specifies the
\emph{first} channel to use for the chord, but other channels will be used for
subsequent notes.  For example, if you specify a channel argument of {\ttfamily
3} for a chord which plays 4 notes, the {\ttfamily FMCHORD} statement will play
the notes on channels 3, 4, 5, and 6.  It is important to set each of the
channels to use the desired instruments with the {\ttfamily FMINST} statement.
The string argument is used to specify which notes the {\ttfamily FMCHORD}
statement will play.  For more information on specifying notes, see the chapter
on Sound.\\

Example:\\

\codeblock{

	REM PLAY A C MAJOR CHORD ON A PIANO\\
	10 FMINST 0,0:FMINST 1,0:FMINST 2,0\\
	20 FMCHORD 0,"CGE"\\

}

\subsection{FMDRUM}

The {\ttfamily FMDRUM} statement plays a single percussion sound from a set of
percussion instruments.  This set comes from the General MIDI standard
Percussion set\footnote{see the Drum Patch Presets table in the appendix},
which uses numbers from 25 through 87.  The {\ttfamily FMDRUM} statement takes
two arguments.  The first is a channel, and the second is a drum number from
the set.  When this statement executes, it sets the channel to the selected
drum number and plays it.  The channel will retain the drum number set until it
is set again with either {\ttfamily FMINST} or another call to {\ttfamily
FMDRUM}.\\

Examples:\\

\begin{tabular}{l p{0.55\linewidth}}

	{\ttfamily\bfseries FMDRUM 0,38}&Play an acoustic snare on channel 0.\\\\

	{\ttfamily\bfseries FMDRUM 2,50}&Play a high tom on channel 2.\\\\

	{\ttfamily\bfseries FMDRUM 1,55}&Play a splash cymbal on channel 1.\\\\

\end{tabular}

\subsection{FMFREQ}

The {\ttfamily FMFREQ} statement plays a note on the FM synthesis chip at a
given frequency.  This is an alternative to playing a note with {\ttfamily
FMNOTE}, where instead of specifying a musical note, a frequency in Hertz is
specified.  Like {\ttfamily FMNOTE} and {\ttfamily FMDRUM}, {\ttfamily FMFREQ}
returns immediately and does not wait for a note to finish playing.  If a Hertz
value of {\ttfamily 0} is specified, the channel is immediately silenced.\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries FMFREQ 3,2600}&Plays the instrument on channel 3 at 2,600hz.\\\\

	{\ttfamily\bfseries FMFREQ 0,440}&Equivalent to {\ttfamily FMNOTE 0,\$4A}
	which plays A above middle C on channel 0.\\\\

	{\ttfamily\bfseries FMFREQ 2,0}&Silences channel 2.\\\\

\end{tabular}

\subsection{FMINIT}

The {\ttfamily FMINIT} statement is used to set the FM synthesis chip to a
known state, and takes no arugments.  It performs initializations on the YM2151
sound chip, as well as loading default patches into all 8 channels.  In
addition, it immediately silences the channels.  This last function can be
useful for silencing multiple FM channels at once, without having to call
{\ttfamily FMNOTE} or {\ttfamily FMFREQ} on each one.  The initializations that
the {\ttfamily FMINIT} statement performs are called automatically when the
Commander X16 boots up, so it is not necessary to call {\ttfamily FMINIT}
directly before using other FM statements.  However, it is still a good idea to
call {\ttfamily FMINIT} before using FM statements in a program, especially if
the program relies on the default patches.  There's no guarantee that another
program hasn't modified the state of the FM chip since boot.\\

\subsection{FMINST}

The {\ttfamily FMINST} statement assigns an instrument to a channel.  The first
argument is the channel, and the second argument is a number indicating an
instrument.  The Commander X16's ROM chip comes pre-loaded with 146 FM
instrument patches from the General MIDI Instrument Set.  These instruments and
their numbers can be found in FM Instrument Patch Presets table and the
Extended FM Instrument Patch Presets table in the appendix.\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries FMINST 0,0}&Set channel 0 to Acoustic Grand Piano.\\\\

	{\ttfamily\bfseries FMINST 3,11}&Set channel 3 to Vibraphone.\\\\

	{\ttfamily\bfseries FMINST 7,127}&Set channel 7 to Gunshot.\\\\

\end{tabular}

\subsection{FMNOTE}

The {\ttfamily FMNOTE} statement plays a single note on the FM synthesis chip.
The first argument is the channel, and the second argument specifies which
note.  The note argument can be any number, but is intended to be specified
with hexadecimal notation.  This is so that the most significant 4 bits (often
called the "high nybble") represent the octave while the least significant 4
bits (the "low nybble") represent the musical note.  The lowest note of any
octave is {\ttfamily\bfseries C}, which is represented with a {\ttfamily 1},
and the highest note of any octave is {\ttfamily\bfseries B}, which is
represented with a {\ttfamily\bfseries C}.  A note of {\ttfamily 0} on any
octave will release the note playing on that channel, and the note values
{\ttfamily\bfseries D}, {\ttfamily\bfseries E}, and {\ttfamily\bfseries F} have
no effect.\\

Although this may seem confusing, it is actually convenient for most uses.
For example to play a "middle C" the note value {\ttfamily \$41} would be used.
The {\ttfamily \$} tells BASIC that the value is hexadecimal, the {\ttfamily 4}
indicates the note is in the 4th octave, and {\ttfamily 1} specifies the note
"C".  Here's a table of which nybble produces which note:\\

\begin{tabular}{|c|c|c|c|c|c|c|c|}
	\hline

	Nybble & \$x0 & \$x1 & \$x2 & \$x3 & \$x4 & \$x5 & \$x6 \\ \hline Note &
	Release & {\ttfamily\bfseries C} & {\ttfamily\bfseries C♯/D♭} &
	{\ttfamily\bfseries D} & {\ttfamily\bfseries D♯/Eb} & {\ttfamily\bfseries
	E} & {\ttfamily\bfseries F} \\ \hline

	Nybble & \$x7 & \$x8 & \$x9 & \$xA & \$xB & \$xC & \$xD-\$xF \\ \hline Note
	& {\ttfamily\bfseries F♯/G♭} & {\ttfamily\bfseries G} & {\ttfamily\bfseries
	G♯/A♭} & {\ttfamily\bfseries A} & {\ttfamily\bfseries A♯/B♭} &
	{\ttfamily\bfseries B} & no-op \\ \hline

\end{tabular}\\

Negative numbers can also be used to specify notes.  These will be treated as
the same note, except it will merely change an already-playing note rather than
re-triggering it.  This is obviously more useful with some instruments than
with others, but can also be used as a clever way to create sound effects.\\

Examples:\\

\codeblock{

	10 FMINST 1,64 : REM LOAD SOPRANO SAX \\
	20 FMNOTE 1,\$4A : REM PLAYS CONCERT A \\
	30 SLEEP 50 : NEXT X : REM DELAYS FOR A BIT \\
	40 FMNOTE 1,0 : REM RELEASES THE NOTE \\
	50 SLEEP 10 : NEXT X : REM DELAYS FOR A BIT \\
	60 FMNOTE 1,\$3A : REM PLAYS A IN THE 3RD OCTAVE \\
	70 SLEEP 25 : NEXT X : REM SHORT DELAY \\
	80 FMNOTE 1,-\$3B : REM A\# WITHOUT RETRIGGERING \\
	90 SLEEP 25 : NEXT X : REM SHORT DELAY \\
	100 FMNOTE 1,0 : REM RELEASES THE NOTE \\

}

\subsection{FMPAN}

The {\ttfamily FMPAN} statement is used to control the stereo output of an FM
channel.  It takes an argument for the channel, and an argument for which
speaker the channel should play from.  The second argument values are as
follows:\\ 

\begin{tabular}{|c|c|}
	\hline
	Left & 1 \\ \hline
	Right & 2 \\ \hline
	Both & 3 \\ \hline
\end{tabular}\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries FMPAN 0,3}&Set channel 0 to play from both speakers.\\\\

	{\ttfamily\bfseries FMPAN 3,1}&Set channel 3 to play from only the left speaker.\\\\

	{\ttfamily\bfseries FMPAN 7,2}&Set channel 7 to play from only the right speaker.\\\\

\end{tabular}

\subsection{FMPLAY}

The {\ttfamily FMPLAY} statement plays a musical melody on a single channel.
{\ttfamily FMPLAY} takes two arguments; a channel and a string of characters
that tells the FM chip what to play.  This second argument is specified in a
custom macro language\footnote{for a complete guide, see the Macro Language for
Music appendix}, and includes notes, releases, tempos, octaves, rests, and
other musical elements.  For example, the following statement will play a major
scale in the key of {\ttfamily\bfseries C}:\\

\codeblock{
	FMPLAY 0,"CDEFGAB>C"\\
}

Each letter indicates which note to play.  Before playing the final
{\ttfamily\bfseries C} note, the {\ttfamily >} character is used to tell the
channel to move up one octave.  If this character wasn't included, the final
{\ttfamily\bfseries C} would play at the same octave as the first
{\ttfamily\bfseries C}.\\

The characters {\ttfamily +} and {\\ttfamily -} can be placed after a note's
letter to indicate sharps and flats, respectively.  For example, the following
will play a major scale in the key of {\ttfamily\bfseries A}:\\

\codeblock{
	FMPLAY 0,"AB>D-DEF+A-A"\\
}

Because a new octave starts on each {\ttfamily\bfseries C} note, this scale
requires the {\ttfamily >} character to be placed between the
{\ttfamily\bfseries B} and {\ttfamily\bfseries D♭} notes.\\

\tip{Restoring Octaves}{

	You may have noticed that running these {\ttfamily FMPLAY} statements
	multiple times results in them playing in different octaves.  This is
	because the Commander X16 remembers which octave each channel was left in.
	So when using {\ttfamily >} to increase the octave on one {\ttfamily
	FMPLAY} statement, the channel stays in that octave during the next
	{\ttfamily FMPLAY} statement.  This can be solved in a number of ways:\\

	\begin{itemize}

		\item An initial octave can be specified at the beginning of the string
			with the {\ttfamily O} macro

		\item A {\ttfamily <} character can be placed at the end of the string
			to indicate that the channel should move down one octave

		\item The octave can be reset with the {\ttfamily FMINIT} statement.
			Just keep in mind that this resets the octaves of \emph{all}
			channels, as well as silencing them and restoring them to their
			default instruments

			

	\end{itemize}



}

\subsection{FMPOKE}

The {\ttfamily FMPOKE} statement can be used to write values directly to the
registers of the FM sound chip.  To understand what values to write to which
registers, see the appendix on YM2551 Registers.\\

Using {\ttfamily FMPOKE}, it is possible to directly interface with the FM chip
and make it do things that are not possible by using the other FM BASIC
statements.  For example, {\ttfamily FMPOKE} can be used to define a new
instrument patch instead of using one of the predefined patches.\\

Examples:\\

\begin{tabular}{l p{0.55\linewidth}}

	{\ttfamily\bfseries FMPOKE \$28,\$4A}&Set {\ttfamily KC} to {\ttfamily A4} on channel 0.\\\\

	{\ttfamily\bfseries FMPOKE \$08,\$00}&Release channel 0.\\\\

	{\ttfamily\bfseries FMPOKE \$08,\$78}&Start note playback on channel 0 with all operators.\\\\

\end{tabular}

\subsection{FMVIB}

The {\ttfamily FMVIB} statement sets the speed of the FM chip's LFO, as well as
the depth of the amplitude modulation or phase modulation.  The first argument
sets the speed from 0-255, and the second argument sets the depth from 0-127.
The {\ttfamily FMVIB} statement applies to all channels, and only to instrument
patches that use either amplitude or phase modulation (see the Instrument Patch
Presets table in the appendix).\\

Example:\\

\codeblock{
	10 FMINST 0,11 : REM SET CHANNEL 0 TO VIBRAPHONE\\
	20 FMVIB 200,60 : REM SET VIBRATO\\
	30 FMNOTE 0,\$4A : REM PLAY CONCERT A\\
}

\subsection{FMVOL}

The {\ttfamily FMVOL} statement sets a channel's volume.  The first argument is
the channel, and the second argument is a value from 0 through 63.  The volume
is maintained for the channel, even if the instrument patch is switched.  Only
another {\ttfamily FMVOL} statement or an {\ttfamily FMINIT} statement will
cause the volume of a channel to change.\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries FMVOL 0,63}&Set channel 0 to full volume.\\\\

	{\ttfamily\bfseries FMVOL 1,31}&Set channel 1 to half volume.\\\\

	{\ttfamily\bfseries FMVOL 2,0}&Set channel 2 to no volume, silencing it.\\\\

\end{tabular}

\subsection{FOR}

The {\ttfamily FOR} statement is used with the {\ttfamily TO} statement, the
{\ttfamily NEXT} statement, and sometimes the {\ttfamily STEP} statement to
create a section of a program that executes a specific number of times.  This
repeating section of a program is commonly called a "for-loop".\\

The format of a for-loop is as follows:\\

\codeblock{
	FOR <loop variable> = <start> TO <end>\\
	<code to execute multiple times ...>\\
	NEXT <loop variable>\\
}

In the above example, {\ttfamily <loop variable>} can be any legal name for a
floating point variable.  Both {\ttfamily <start>} and {\ttfamily <end>} are
floating point values, and both variables and constants are allowed.\\

For example, here is a for-loop that prints the numbers {\ttfamily 1} through
{\ttfamily 10} to the screen:\\

\codeblock{
	FOR X = 1 TO 10\\
	PRINT X\\
	NEXT X\\
}

\subsection{FRAME}

The {\ttfamily FRAME} statement draws a rectangle frame in graphics mode in a
given color.  The first two arguments are the x and y coordinates for the upper
left corner of the frame.  The third and fourth arguments are the x and y
coordinates for the lower right corner of the frame.  The fifth argument is a
number from 0-255 that specifies the color from the current palette.\\

Example:\\

\codeblock{
	10 SCREEN \$80\\
	20 FRAME 10,10,310,230,2\\
}

The {\ttfamily FRAME} statement is similar to the {\ttfamily RECT} statment,
except that {\ttfamily FRAME} does not fill in the rectangle.

\subsection{GET}

The {\ttfamily GET} statement gets data from the keyboard one character at a
time.  The {\ttfamily GET} statement will read a single character from the
keyboard cache and place it into a variable provided as an argument.  Any
character can be placed into a string variable, but only numeric characters can
be placed into integer or floating point variables.  When the keyboard cache is
empty (no keys are currently pressed), a default value is placed into the
specified variable.  For string variables the default value will be the empty
string ({\ttfamily ""}), but for floating point and integer variables the
default value will be {\ttfamily 0.0} and {\ttfamily 0}, respectively.\\

If there are more than one characters currently in the keyboard cache,
then a single call to {\ttfamily GET} can retrieve them all by specifying
multiple variables as arguments.\\

Examples:\\

\begin{tabular}{l p{0.75\linewidth}}

	{\ttfamily\bfseries GET A\$} & Read a single character from the keyboard into {\ttfamily A\$}\\\\

	{\ttfamily\bfseries GET I\%} & Read a single character from the keyboard
	into {\ttfamily I\%}, and cause an error if that character is not
	numeric\\\\

	{\ttfamily\bfseries GET F} & Read a single character from the keyboard into
	{\ttfamily F}, and cause an error if that character is not numeric\\\\

	{\ttfamily\bfseries GET A\$,B\$} & Read two characters from the keyboard
	cache into {\ttfamily A\$} and {\ttfamily B\$}\\\\

\end{tabular}

\vspace{16pt}

A common use for the {\ttfamily GET} statement is to pause a program in a loop until the user presses a key:\\

\codeblock{
	10 PRINT "PRESS ANY KEY TO CONTINUE"\\
	20 GET A\$:IF A\$="" GOTO 20\\
	30 PRINT "THANK YOU FOR PRESSING A KEY!"\\
}

\subsection{GET\#}

The {\ttfamily GET\#} statement reads data from a specified logical file one
character at a time.  It is identical to the {\ttfamily GET} statement except
that it requires a first argument to specify a logical file identifier.  The
logical file must first be opened with the {\ttfamily OPEN} statement.  The
remaining arguments work just the same as with the {\ttfamily GET} statement.\\

Example:\\

\codeblock{
	10 OPEN 1,1,0,"FILENAME" : REM OPEN TAPE DRIVE FILE\\
	20 GET\#1,A\$ : REM READ A CHARACTER FROM THE TAPE\\
}

\note{

	It is a popular convention when using statements and commands that end in
	{\ttfamily \#} to place the logical file identifier directly after the
	command with no space.  So instead of {\ttfamily GET\#~1,A\$} this example shows {\ttfamily GET\#1,A\$}.

}


\subsection{GOSUB}

The {\ttfamily GOSUB} statement transfers program execution to a specified line
and remembers which line which called {\ttfamily GOSUB}.  This is different
than the {\ttfamily GOTO} statement which transfers program execution, but does
not have a way to return control to the line which called {\ttfamily GOTO}.
The {\ttfamily GOSUB} statement allows for the creation of {\em subroutines}
(often called {\em functions}, {\em procedures}, or {\em methods} in other
programming languages).  After {\ttfamily GOSUB} is called and program
execution has been transfered to a new line, the next time a {\ttfamily RETURN}
statement is executed it will transfer program execution back to the line
directly {\em after} the {\ttfamily GOSUB} statement.\\

Example:\\

\codeblock{
	10 PRINT "FIRST"\\
	20 GOSUB 50\\
	30 PRINT "THIRD"\\
	40 END\\
	50 PRINT "SECOND"\\
	60 RETURN\\
}

The above program will print {\ttfamily FIRST}, {\ttfamily SECOND}, and
{\ttfamily THIRD} in order.  This is because the {\ttfamily GOSUB} statement on
line 20 transfers execution to line 50, and then the {\ttfamily RETURN}
statement on line 60 transfers execution back to line 30, which is the
line {\em after} the {\ttfamily GOSUB} statement was called.  Line 40 ends the 
program, which stops line 50 from executing again.\\

\tip{Nesting Subroutines}{

	It is possible to "nest" subroutines created by {\ttfamily GOSUB} such that
	a subroutine calls a subroutine which calls a subroutine...and so on!  This
	can be useful for creating BASIC programs with complex logic.\\

}

\subsection{GOTO}

The {\ttfamily GOTO} statement transfers program execution to the line
specified.  Unlike the {\ttfamily GOSUB} statement, the {\ttfamily GOTO}
statement does {\em not} remember where it was called from, and therefore the
{\ttfamily RETURN} statement will {\em not} return program execution.\\

Example:\\

\codeblock{
	10 PRINT "THIS WILL PRINT"\\
	20 GOTO 40\\
	30 PRINT "THIS WILL NOT PRINT"\\
	40 PRINT "THIS WILL ALSO PRINT"\\
}

\subsection{IF}

The {\ttfamily IF} statement is how decisions are made in BASIC.  The
{\ttfamily IF} statement is followed by an expression that evaluates to either
{\ttfamily TRUE} or {\ttfamily FALSE}, and the next statement executed is
dependent on the outcome.  The expression is followed by either a {\ttfamily
THEN} statement or a {\ttfamily GOTO} statement.  A {\ttfamily THEN} statement
is followed by another statement or a line number, and a {\ttfamily GOTO
statement} is followed by a line number.  If the expression evaluates to
{\ttfamily TRUE}, then the statement following the {\ttfamily THEN} statement
is executed.  If a line number is used, either with a {\ttfamily THEN} or
{\ttfamily GOTO} statement, then the program will jump to that line number.
When the expression evaluates to {\ttfamily FALSE}, then the line after the
{\ttfamily IF} statement is executed.\\

Expressions can be either a variable or a formula.  In both cases a zero is
considered {\ttfamily FALSE}, and any non-zero value is considered {\ttfamily
TRUE}.  In most cases, the statement will be constructed from variables,
comparison operators, and logical operators.  See the section on operators for
more details.\\

Example:\\

\codeblock{

	10 A=10\\
	20 IF A=9 THEN 40\\
	30 IF A=10 THEN 60\\
	40 PRINT "THIS SHOULD NOT PRINT"\\
	50 END\\
	60 PRINT "THIS SHOULD PRINT"\\

}

\subsection{INPUT}

The {\ttfamily INPUT} statement asks the user of a BASIC program for data to
store in a variable.  The program will print an optional prompt (much like the
{\ttfamily PRINT} statement), print a question mark (?), and then wait for the
user to type something and press
\keybackgroundcolor{gray}\keytextcolor{black}\widekey{RETURN}.\\

The optional prompt must be followed by a semicolon (;) and a variable or
comma-separated list of variables.  When there are multiple variables, the
{\ttfamily INPUT} statement will stop and wait for the user to type something
and hit \widekey{RETURN} for each one of the variables listed.  If no prompt is
given, then the semicolon (;) should not be used.\\

Example:\\

\codeblock{

	10 INPUT "PLEASE TYPE A NUMBER";A\\
	20 INPUT "AND YOUR NAME";A\$\\
	30 INPUT B\$\\
	40 PRINT "BET YOU DIDN'T KNOW WHAT I WANTED!"\\
	50 INPUT "TYPE 2 NUMBERS AND A STRING";A,B,C\$\\
	60 PRINT A,B,C\$\\

}


\subsection{INPUT\#}

The {\ttfamily INPUT\#} statement works just like the {\ttfamily INPUT}
statement, but takes the data from a previously opened file or device.  The
device number must be specified before the optional prompt or the variables.\\

\subsection{LET}

The {\ttfamily LET} statement is an optional statement used for assigning
variables in a BASIC program.  It is not necessary, but still exists as part of
the BASIC language for compatibility purposes.\\

Example:\\

\codeblock{
	10 LET A=5\\
	20 B=6\\
	30 PRINT A+B\\
	40 LET B=7\\
	50 PRINT A+B\\
}

The above code prints {\ttfamily 11} and {\ttfamily 12}, respectively, showing
that using {\ttfamily LET} on variable assignments is optional.

\subsection{I2CPOKE}

The {\ttfamily I2CPOKE} statement sets a value in a register of an
I\textsuperscript{2}C device.  The first argument is the device, the second is
the register on the device, and the third is the value to set.\\

Example:\\

\codeblock{

	10 REM SET NVRAM ON RTC
	20 I2CPOKE \$6F,\$40,\$80\\

}

\subsection{LINE}

The {\ttfamily LINE} statement is used to draw a line in graphics mode.  The
{\ttfamily LINE} statement is passed the X and Y coordinates of the first
point, followed by the X and Y coordinates of the second point, followed by the
color of the line.  The {\ttfamily LINE} statement can only be used in graphics
mode, which must be set by calling the {\ttfamily SCREEN} statement with
{\ttfamily \$80}.\\

Examples:\\

Draw a red X across the screen.\\

\codeblock{
	10 SCREEN \$80\\
	20 LINE 0,0,319,239,2\\
	30 LINE 0,239,319,0,2\\
}

Draw a rainbow.\\

\codeblock{
	10 SCREEN \$80\\
	20 FOR I=0 TO 255\\
	30 LINE 159,0,I+32,239,I\\
	40 NEXT I\\
}

\subsection{LINPUT}

The {\ttfamily LINPUT} statement reads input directly from the keyboard, but
always stores the data as a string varible.  Unlike the the {\ttfamily INPUT}
statement, which attempts to parse the value entered into whichever variable
type was supplied by the programmer, the {\ttfamily LINPUT} stores the data as
a string just as the user typed it.  This includes storing any quotation marks,
commas, or colons that the user types.  The {\ttfamily LINPUT} statement does
not allow for a prompt to to be specified, so the only argument passed to the
the {\ttfamily LINPUT} statement is the string variable used to store the
user's input.\\

Example:\\

\codeblock{
	10 PRINT "ENTER ANY TEXT FOR LINPUT:  ";\\
	20 LINPUT A\$\\
	30 PRINT A\$\\
	40 PRINT "ENTER ANY TEXT FOR INPUT:  ";\\
	50 INPUT A\$\\
	60 PRINT A\$\\
}

Try running the above program several times, and using the same value at both
prompts.  Here's some values to try:\\

\begin{tabular}{l}

	{\ttfamily "TEST"}\\
	{\ttfamily 3,4,5}\\
	{\ttfamily 11:45 AM}\\

\end{tabular}

\vspace{16pt}

You will find that each of the above examples will have a different result when
ready by {\ttfamily LINPUT} as opposed to {\ttfamily INPUT}.\\

\subsection{LINPUT\#}

The {\ttfamily LINPUT\#} works similar to the {\ttfamily LINPUT} statement, but
instead reads the line from an open file specified by the first argument.  When
reading from a file, there are no "lines" to read from like there is when
entering data with either the {\ttfamily INPUT} or {\ttfamily LINPUT}
statements, so data is read until a carriage return character ({\ttfamily 13})
is reached.  The data is stored in a string variable supplied as the second
argument.  The carriage return character is not included as the input.  If the
end of the file is reached, the {\ttfamily LINPUT\#} statement will set the
sixth bit of the {\ttfamily ST} special variable.  This means the end of the
file can be detected with {\ttfamily ST AND 64}.\\

Example:\\

\codeblock{
	10 I=0\\
	20 OPEN 1,8,0,"\$"\\
	30 LINPUT\#1,A\$,\$22\\
	40 IF ST<>0 THEN 130\\
	50 LINPUT\#1,A\$,\$22\\
	60 IF I=0 THEN 90\\
	70 PRINT "ENTRY: ";\\
	80 GOTO 100\\
	90 PRINT "LABEL: ";\\
	100 PRINT CHR\$(\$22);A\$;CHR\$(\$22)\\
	110 I=I+1\\
	120 IF ST=0 THEN 30\\
	130 CLOSE 1\\
}

The above example parses and prints out the filenames from a directory
listing.\\

\subsection{LOCATE}

The {\ttfamily LOCATE} statement moves the cursor in text mode, allowing a
program to print text to any part of the screen.  The {\ttfamily LOCATE}
statement takes a line as the first argument, and a column as an optional
second argument.  Both the line and the column numbers are 1-based (the first
line is {\ttfamily 1} and the first column is {\ttfamily 1}), the column is
{\ttfamily 1} if no column argument is given.\\

Examples:

\begin{tabular}{l p{0.85\linewidth}}

	{\ttfamily\bfseries LOCATE 20} & Move the cursor to line 20 and column
	1\\\\

	{\ttfamily\bfseries LOCATE 20,30} & Move the cursor to line 20 and column
	30\\\\

	{\ttfamily\bfseries LOCATE 1,1} & Move the cursor to the top left corner\\\\

\end{tabular}

\vspace{16pt}

\subsection{MOUSE}

The {\ttfamily MOUSE} statement shows or hides the mouse cursor by passing a
mode as an argument:\\

\begin{tabular}{|c|l|}
	\hline
	
	{\bfseries Mode} & {\bfseries Description} \\ \hline
	{\ttfamily 0} & Hides the mouse cursor \\ \hline
	{\ttfamily 1} & Shows the mouse cursor with the default sprite \\ \hline
	{\ttfamily -1} & Shows the mouse cursor without changing the sprite\\ \hline

\end{tabular}

\vspace{16pt}

A hardware sprite\footnote{See the chapter on Graphics} with the index of
{\ttfamily 0} is used to display the mouse cursor.  If the {\ttfamily MOUSE}
statement is given a {\ttfamily 1}, it will set sprite 0's pixel data to VRAM
address {\ttfamily \$13000} and copy the default mouse cursor data to that
location.  If the {\ttfamily MOUSE} statement is given a {\ttfamily -1}, it
will display the sprite but change neither its pixel data address nor the data
that resides there.  This behavior is useful for written a program that sets a
custom mouse cursor.\\

The size of the sprite will automatically be set based on the screen mode.
Changing the screen mode while the mouse is displayed will automatically hide
it.\\

Examples:\\

\begin{tabular}{l p{0.85\linewidth}}

	{\ttfamily\bfseries MOUSE 1} & Show mouse cursor using default cursor\\\\

	{\ttfamily\bfseries MOUSE -1} & Show mouse cursor using existing sprite 0 \\\\

	{\ttfamily\bfseries MOUSE 0} & Hide mouse cursor\\\\

\end{tabular}

\vspace{16pt}

The cursor sprite can also be changed by directly changing the VRAM where it is
read from.  This a program that will change the mouse cursor to be a miniature
version of the default VERA palette:\\

\codeblock{
	10 MOUSE 1\\
	20 FOR I=0 to 255\\
	30 VPOKE 1,\$3000+I,I\\
	40 NEXT I\\
}

\subsection{MOVSPR}

The {\ttfamily MOVSPR} statement moves a sprite to a location on the screen.
The {\ttfamily MOVSPR} statement requires three integer arguments.  The first
argument is the sprite index, the second is the location along the x-axis, and
the third the location along the y-axis.  The {\ttfamily MOVSPR} statement will
position the sprite's most upper left pixel pixel at the given XY coordinates,
regardless of whether that pixel is visible or not.  To use a hardward sprite,
see the documentation for the {\ttfamily SPRITE} and {\ttfamily SPRMEM}
statements.\\

Example:\\

\codeblock{
10 REM FILL A SPRITE VRAM WITH PIXEL DATA\\
20 FOR I=0 to 255\\
30 VPOKE 1,\$4000+I,I\\
40 NEXT I\\
50 SPRMEM 1,1,\$4000,1\\
60 SPRITE 1,3,0,0,1,1\\
70 MOVSPR 1,100,100\\
}

The above code will create a sprite that's a 16x16 pixel version of the default
VERA palette, and then position it at coordinates (100,100).\\

\subsection{NEXT}

The {\ttfamily NEXT} statement is used as part of a for-loop in BASIC.  Each
use of the {\ttfamily FOR} statement will need a corresponding {\ttfamily NEXT}
statement, and {\ttfamily NEXT} will never be used without {\ttfamily FOR}.
When a program reaches the {\ttfamily NEXT} statement, the program goes back to
the corresponding {\ttfamily FOR} statement and evaluates whether it needs to
re-enter the loop or not.\\

A {\ttfamily NEXT} statement can take no arguments, or it can take many
arguments specified as a comma-separated listed.  These arguments must be loop
counter variables that were created by by {\ttfamily FOR} loops.   When no
arguments are supplied, the {\ttfamily NEXT} statement will return control to
the last {\ttfamily FOR} statement that was started.  If loop counter arguments
are supplied, the {\ttfamily NEXT} statement will will evaluate the variables
from left to right, completing the first loop counter's for-loop before jumping
to the next.\\

 Examples:\\

\begin{tabular}{l}

	{\ttfamily\bfseries FOR L=1 to 10:NEXT}\\\\

	{\ttfamily\bfseries FOR L=1 to 10:NEXT L}\\\\

	{\ttfamily\bfseries FOR L=1 to 10:FOR M=1 to 10:NEXT M,L}\\\\

\end{tabular}

\vspace{16pt}

\subsection{ON}

The {\ttfamily ON} statement can be used to change the target line number of a
{\ttfamily GOTO} or {\ttfamily GOSUB} statement.  The {\ttfamily ON} statement
is followed by an expression that evaluates to a number, then followed by
either a {\ttfamily GOTO} or {\ttfamily GOSUB} statement, which is in turn
followed by a comma-separated list of line numbers.  Which line is used as the
target of the {\ttfamily GOTO} or {\ttfamily GOSUB} statement depends on the
result of the numerical expression\footnote{The {\ttfamily ON} statement works
very similar to how {\ttfamily switch} or {\ttfamily select} works in other
programming languages}.  For example, if the expression {\ttfamily 1} is given,
then the {\ttfamily GOTO} or {\ttfamily GOSUB} would select the first line
number in the comma-separated list.  If the expression {\ttfamily 1+2} is
given, the third line number in the list would be selected.  If the expression
evaluates to {\ttfamily 0} or any number higher than the number of line numbers
in the list, the program moves to the next line.  If the expression evaluates
to any number outside {\ttfamily 0} to {\ttfamily 255} an error occurs.\\

Example:\\

\codeblock{

	10 INPUT X\\
	20 ON X GOTO 10,50,50,50\\
	30 PRINT "NOPE!"\\
	40 GOTO 10\\
	50 PRINT "YUP!"\\
	60 ON X GOTO 10,30,30\\

}

\tryit{

	Type in the above program and see if you can figure out what number needs
	to be entered in order to exit the program!

}

\subsection{OPEN}

The {\ttfamily OPEN} statement can be used to access various devices from
within a BASIC program on the Commander X16.  These devices may be the
keyboard, the screen (in text mode), disk drives, and printers.  The first
argument to the {\ttfamily OPEN} statement is any number from 1 to 255 that
will be used to refer to the {\ttfamily OPEN}ed device from other BASIC
statements.  The second argument is a number that specifies which device to
{\ttfamily OPEN}.  The default devices available on the Commander X16 are:\\

\begin{tabular}{|c|p{0.35\linewidth}|p{0.45\linewidth}|}
	\hline
	{\bfseries Device \#} & {\bfseries Description} & {\bfseries Secondary Address}\\ \hline

	0 & Keyboard & (none)\\ \hline

	1 & (unused) & (none)\\ \hline

	2 & (unused) & (none)\\ \hline

	3 & Screen & 0 or 1\\ \hline

	4-5 & Printer (or other IEC device) & 0 = capital letters/graphic characters; 7 = capital/lowercase letters\\ \hline

	6-30 & IEC Bus devices (SD card is 8 at boot, but can be reassigned) & 0 = read; 1 = write; 2-14
	= data channels; 15 channel for commands\\ \hline

\end{tabular}\\

\vspace{16pt}

Many devices may require a third, or even a fourth argument to be passed to
{\ttfamily OPEN}.  The Secondary Address column of the above table shows some
of the available values for the third argument on the various devices.  For
disk drives, a fourth argument specifies the name of a file.\\


Examples:\\

\begin{tabular}{l p{0.55\linewidth}}

	{\ttfamily\bfseries OPEN 1,0} & {\ttfamily OPEN}s the keyboard as a device\\\\

	{\ttfamily\bfseries OPEN 3,8,0,"MYFILE"} & {\ttfamily OPEN}s a file on the SD card\\\\

	{\ttfamily\bfseries OPEN 4,9,15} & {\ttfamily OPEN}s the data channel on a disk configured as device 9\\\\

\end{tabular}

\subsection{OVAL}

The {\ttfamily OVAL} statement draws a filled oval in graphics mode in a given
color.  The first two arguments are the x and y coordinates for the upper left
corner of the bounding rectangle that contains the oval.  The third and fourth
arguments are the x and y coordinates for the lower right corner of the
bounding rectangle.  The oval itself will be drawn as an ellipse that fits just
inside the specified bounding rectangle.  The fifth argument is a number from
0-255 that specifies the color from the current palette.\\

Example:\\

\codeblock{
	10 SCREEN \$80\\
	20 OVAL 57,17,262,222,0\\
	30 OVAL 60,20,259,219,7\\
	40 OVAL 100,80,220,180,0\\
	50 OVAL 100,79,220,170,7\\
	60 OVAL 120,60,140,100,0\\
	70 OVAL 180,60,200,100,0\\
	80 LOCATE 30,13\\
	90 PRINT "HAVE A NICE DAY!"\\
}

The {\ttfamily OVAL} statement is similar to the {\ttfamily RING} statement,
except that {\ttfamily RECT} fills the ellipse with the specified color.

\subsection{POKE}

The {\ttfamily POKE} statement is used to write directly to the Commander X16's
memory or a memory-mapped device.  It is always followed by two numbers or
expressions that evaluate to numbers.  The first is the address in the memory
map, which can be any value from 0-65535\footnote{Since the Commander X16
supports hexadecimal values, it's easier to think of this as \$0000-\$FFFF}.
The second argument is the value to write to the specified address.  Because
the Commander X16 is an 8-bit computer, so each address only holds one byte of
data.  Therefore, any value from 0-255 is allowed.\\

The {\ttfamily POKE} statement is very powerful, since it is able to write not
only to memory, but also the memory mapped hardware such as the VERA.  To learn
about the regions of memory available and the memory mapped hardware, see the
{\bfseries Memory Map} appendix.\\

Examples:\\

\begin{tabular}{l p{0.55\linewidth}}

	{\ttfamily\bfseries POKE 2048,64} & Write {\ttfamily 64} to address {\ttfamily 2048}\\\\

	{\ttfamily\bfseries POKE \$800,\$40} & Same as above, but denoted in hexadecimal\\\\

	{\ttfamily\bfseries POKE 0,1} & Writea {\ttfamily 1} to address {\ttfamily
	\$0000}, which switches the Commander X16 to use RAM bank 1\\\\

\end{tabular}

\subsection{PRINT}

The {\ttfamily PRINT} statement is used to display text and graphic characters
to the screen.  When it text mode, it is the most typical way to display output
of a program to a user.  The {\ttfamily PRINT} statement can be followed by any
of the following:\\

\begin{itemize}

	\item {\bfseries Characters inside of quotation marks} - Called
		\emph{literals} because they are printed literally as they are typed
		in

	\item {\bfseries Variables} - {\ttfamily PRINT}'s' the value the variable
		currently holds

	\item {\bfseries Functions} - {\ttfamily PRINT}'s' the value returned by
		the function

	\item {\bfseries Punctuation marks} - Provides formatting options:
		\begin{itemize}

			\item {\bfseries Comma ({\ttfamily ,})} - Advances to the next
				column, where each column is 10 characters wide

			\item {\bfseries Semicolon ({\ttfamily ;})} - Does not advance to
				the next line after

		\end{itemize}


\end{itemize}

Because commas have a special meaning for formatting, commas should not be used
to separate {\ttfamily PRINT}ing multiple literals, variables, or functions
when output with a single {\ttfamily PRINT}.

Examples:\\

\begin{tabular}{l p{0.55\linewidth}}

	{\ttfamily\bfseries PRINT "HELLO"} & {\ttfamily PRINT}s "HELLO" to the screen\\\\

	{\ttfamily\bfseries PRINT "HELLO, "A\$} & {\ttfamily PRINT}s "HELLO, "
	followed by the value of {\ttfamily A\$}\\\\

	{\ttfamily\bfseries PRINT A+B} & {\ttfamily PRINT}s The result of {\ttfamily A+B}\\\\

	{\ttfamily\bfseries PRINT J} & {\ttfamily PRINT}s the value of {\ttfamily J}\\\\

	{\ttfamily\bfseries PRINT A,B,C,D} & {\ttfamily PRINT}s the values of each
	variable formatted into columns\\\\

\end{tabular}

\subsection{PRINT\#}

The {\ttfamily PRINT\#} statement works nearly identically to the {\ttfamily
PRINT} statement, except that it {\ttfamily PRINT}s to an open file or device
instead of the screen.  The first argument to the {\ttfamily PRINT\#} statement
must be a number used to identify the open file or device.  This must be a
number that was used with an {\ttfamily OPEN} statement to open the file or
device.  This number is followed by a comma, which is followed by the value to
be printed.  This can be any of the options available to the {\ttfamily PRINT}
statement, including commas and semicolons used for formatting.  Not every
device that can be written to with {\ttfamily PRINT\#} will be able to handle
formatting.\\

Example:\\

\codeblock {
	10 OPEN 1,8,1,"MYFILE"\\
	20 FOR J=1 to 10\\
	30 FOR I=1 to J\\
	40 PRINT\#1,"*",;\\
	50 NEXT I\\
	60 PRINT\# 1,""\\
	70 NEXT J\\
	80 CLOSE 1\\
}

The above example will write a file named "MYFILE" to the SD card, containing a
pattern of asterisks.  To view the file, use the Command X16's built-in text
editor:\\

\codeblock{
	EDIT "MYFILE"\\
}

The file should contain the following pattern:\\

\codeblock{
	*\\
	**\\
	***\\
	****\\
	*****\\
	******\\
	*******\\
	********\\
	*********\\
	**********\\
}

\subsection{PSET}

The {\ttfamily PSET} statement sets the color of a single pixel in graphics
mode (set with {\ttfamily SCREEN \$80}).  The {\ttfamily PSET} statement is
followed by the x and y coordinates and number from 0-255 to specify the color
from the palette.\\

Example:\\

\codeblock{
	10 SCREEN\$80\\
	20 FOR Y=0 to 239\\
	30 FOR X=0 to 319\\
	40 C=INT(Y/15)*16+INT(X/15)\\
	50 PSET X,Y,C\\
	60 NEXT X,Y\\
}

The above program uses {\ttfamily PSET} to display the default VERA color
palette to the screen.  Because it calculates and draws each pixel one at a
time, it takes a few minutes to complete.  After all, it has 76,800 pixels to
calculate!  See the {\ttfamily RECT} statement for a much faster way to display
the palette.  It only has to calculate the color 256 times.\\

\subsection{PSGCHORD}

The {\ttfamily PSGCHORD} statement instructs the programmable sound generator
to begin playing multiple notes at the same time.  For arguments, the
{\ttfamily PSGCHORD} statement accepts a channel and a string.  Because a chord
plays multiple notes at the same time, the channel argument specifies the
\emph{first} channel to use for the chord, but other channels will be used for
subsequent notes.  For example, if you specify a channel argument of {\ttfamily
3} for a chord which plays 4 notes, the {\ttfamily PSGCHORD} statement will
play the notes on channels 3, 4, 5, and 6.  It is important to set each of the
channels to use the desired waveform with the {\ttfamily PSGWAV} statement.
The string argument is used to specify which notes the {\ttfamily PSGCHORD}
statement will play.  For more information on specifying notes, see the chapter
on Sound.\\

Example:\\

\codeblock{

	REM PLAY A C MAJOR CHORD ON WITH A PULSE WAVEFORM\\
	10 PSGWAV 0,63:PSGWAV 1,63:PSGWAV 2,63\\
	20 PSGCHORD 0,"CGE"\\

}

\subsection{PSGFREQ}

The {\ttfamily PSGFREQ} statement plays a note on the programmable sound
generator at a given frequency.  This is an alternative to playing a note with
{\ttfamily PSGNOTE}, where instead of specifying a musical note, a frequency in
Hertz is specified.  Like {\ttfamily PSGNOTE}, {\ttfamily PSGFREQ} returns
immediately and does not wait for a note to finish playing.  If a Hertz value
of {\ttfamily 0} is specified, the channel is immediately silenced.\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries PSGFREQ 3,2600}&Plays the waveform on channel 3 at 2,600hz.\\\\

	{\ttfamily\bfseries PSGFREQ 0,440}&Equivalent to {\ttfamily PSGNOTE 0,\$4A}
	which plays A above middle C on channel 0.\\\\

	{\ttfamily\bfseries PSGFREQ 2,0}&Silences channel 2.\\\\

\end{tabular}

\subsection{PSGINIT}

The {\ttfamily PSGINIT} statement initializes the VERA's programmable sound
generator (PSG).  When the {\ttfamily PSGINIT} statement is run, it initializes
the PSG, and does the following on all 16 channels:\\

\begin{itemize}

	\item silences the channel

	\item sets the volume to 63 (the maximum)

	\item sets the waveform to pulse with a duty cycle of 50\%

\end{itemize}

\subsection{PSGNOTE}

The {\ttfamily PSGNOTE} statement plays a single note on the programmable sound
generator.  The first argument is the channel, and the second argument
specifies which note.  The note argument can be any number, but is intended to
be specified with hexadecimal notation.  This is so that the most significant 4
bits (often called the "high nybble") represent the octave while the least
significant 4 bits (the "low nybble") represent the musical note.  The lowest
note of any octave is {\ttfamily\bfseries C}, which is represented with a
{\ttfamily 1}, and the highest note of any octave is {\ttfamily\bfseries B},
which is represented with a {\ttfamily\bfseries C}.  A note of {\ttfamily 0} on
any octave will release the note playing on that channel, and the note values
{\ttfamily\bfseries D}, {\ttfamily\bfseries E}, and {\ttfamily\bfseries F} have
no effect.\\

Although this may seem confusing, it is actually convenient for most uses.
For example to play a "middle C" the note value {\ttfamily \$41} would be used.
The {\ttfamily \$} tells BASIC that the value is hexadecimal, the {\ttfamily 4}
indicates the note is in the 4th octave, and {\ttfamily 1} specifies the note
"C".  Here's a table of which nybble produces which note:\\

\begin{tabular}{|c|c|c|c|c|c|c|c|}
	\hline

	Nybble & \$x0 & \$x1 & \$x2 & \$x3 & \$x4 & \$x5 & \$x6 \\ \hline Note &
	Release & {\ttfamily\bfseries C} & {\ttfamily\bfseries C♯/D♭} &
	{\ttfamily\bfseries D} & {\ttfamily\bfseries D♯/Eb} & {\ttfamily\bfseries
	E} & {\ttfamily\bfseries F} \\ \hline

	Nybble & \$x7 & \$x8 & \$x9 & \$xA & \$xB & \$xC & \$xD-\$xF \\ \hline Note
	& {\ttfamily\bfseries F♯/G♭} & {\ttfamily\bfseries G} & {\ttfamily\bfseries
	G♯/A♭} & {\ttfamily\bfseries A} & {\ttfamily\bfseries A♯/B♭} &
	{\ttfamily\bfseries B} & no-op \\ \hline

\end{tabular}\\

Negative numbers can also be used to specify notes.  These will be treated as
the same note as the positive value.\\

Example:\\

\codeblock{

	10 PSGWAV 1,63 : REM PULSE WITH 50\% DUTY CYCLE\\
	20 PSGNOTE 1,\$4A : REM PLAYS CONCERT A \\
	30 SLEEP 50 : NEXT X : REM DELAYS FOR A BIT \\
	40 PSGNOTE 1,0 : REM RELEASES THE NOTE \\
	50 SLEEP 10 : NEXT X : REM DELAYS FOR A BIT \\
	60 PSGNOTE 1,\$3A : REM PLAYS A IN THE 3RD OCTAVE \\
	70 SLEEP 25 : NEXT X : REM SHORT DELAY \\
	80 PSGNOTE 1,-\$3B : REM A\# WITHOUT RETRIGGERING \\
	90 SLEEP 25 : NEXT X : REM SHORT DELAY \\
	100 PSGNOTE 1,0 : REM RELEASES THE NOTE \\

}

\subsection{PSGPAN}

The {\ttfamily PSGPAN} statement is used to control the stereo output of a PSG
channel.  It takes an argument for the channel, and an argument for which
speaker the channel should play from.  The second argument values are as
follows:\\ 

\begin{tabular}{|c|c|}
	\hline
	Left & 1 \\ \hline
	Right & 2 \\ \hline
	Both & 3 \\ \hline
\end{tabular}\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries PSGPAN 0,3}&Set channel 0 to play from both speakers.\\\\

	{\ttfamily\bfseries PSGPAN 3,1}&Set channel 3 to play from only the left speaker.\\\\

	{\ttfamily\bfseries PSGPAN 7,2}&Set channel 7 to play from only the right speaker.\\\\

\end{tabular}

\subsection{PSGPLAY}

The {\ttfamily PSGPLAY} statement plays a musical melody on a single channel.
{\ttfamily PSGPLAY} takes two arguments; a channel and a string of characters
that tells the programmable sound generator what to play.  This second argument
is specified in a custom macro language\footnote{for a complete guide, see the
Macro Language for Music appendix}, and includes notes, releases, tempos,
octaves, rests, and other musical elements.  For example, the following
statement will play a major scale in the key of {\ttfamily\bfseries C}:\\

\codeblock{
	PSGPLAY 0,"CDEFGAB>C"\\
}

The {\ttfamily PSGPLAY} statement uses the exact same macro language as the
{\ttfamily FMPLAY} statement, so see the section on {\ttfamily FMPLAY} for more
information.

\subsection{PSGVOL}

The {\ttfamily PSGVOL} statement sets a channel's volume.  The first argument
is the channel, and the second argument is a value from 0 through 63.  The
volume is maintained for the channel, even if the waveform is switched.  Only
another {\ttfamily PSGVOL} statement or an {\ttfamily PSGINIT} statement will
cause the volume of a channel to change.\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries PSGVOL 0,63}&Set channel 0 to full volume.\\\\

	{\ttfamily\bfseries PSGVOL 1,31}&Set channel 1 to half volume.\\\\

	{\ttfamily\bfseries PSGVOL 2,0}&Set channel 2 to no volume, silencing it.\\\\

\end{tabular}

\subsection{PSGWAV}

The {\ttfamily PSGWAV} statement sets the waveform of a channel on the
programmable sound generator (PSG), which results in a different timbre.  The
first argument is the channel, and the second argument indicates which wavform
to use.  There are four wavforms to choose from: pulse (square wave), sawtooth,
triangle, and noise.  If using the pulse waveform, the duty cycle\footnote{The
"duty cycle" of a square wave is the percentage of the time that the wave is
"high" compared to the total period of the wave} of the wavform can also be
specified.  Here are the values to use with the second argument for each
waveform:\\

\begin{tabular}{|c|c|c|}
	\hline

	0-63 & Pulse &Duty cycle = {\ttfamily (VAL+1)/128}\\ \hline

	64-127 & Sawtooth & All values have identical effect\\ \hline

	128-191 & Triangle & All values have identical effect\\ \hline

	192-255 & Noise & All values have identical effect\\ \hline

\end{tabular}\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries PSGWAV 0,63}&Set channel 0 to Pulse with a 50\% duty cycle.\\\\

	{\ttfamily\bfseries PSGWAV 0,31}&Set channel 0 to Pulse with a 25\% duty cycle.\\\\

	{\ttfamily\bfseries PSGWAV 1,64}&Set channel 1 to Sawtooth.\\\\

	{\ttfamily\bfseries PSGWAV 2,128}&Set channel 2 to Triangle.\\\\

	{\ttfamily\bfseries PSGWAV 3,192}&Set channel 3 to Noise.\\\\

\end{tabular}

\subsection{READ}

The {\ttfamily READ} statement is used to get information that has been coded
into the program using {\ttfamily DATA} statements.  Like the {\ttfamily INPUT}
statement, the {\ttfamily READ} statement is followed by a variable that
matches the type of data being read.  The first time a {\ttfamily READ}
statement is encountered in a program, the first piece of data specified by a
{\ttfamily DATA} statement is read into the variable.  The next time, a
{\ttfamily READ} statement is encountered, it {\ttfamily READ}s the next piece
of data specified by a {\ttfamily DATA} statement, and so on.  If the type of
the data and the type of the variable do not match, a {\ttfamily TYPE MISMATCH
ERROR} will occur.\\

\codeblock{
	10 READ A\$\\
	30 READ B\\
	40 READ C\%\\
	50 PRINT A\$,B,C\%\\
	60 DATA "A VALUE"\\
	70 DATA 27.5,42\\
}

\subsection{RECT}

The {\ttfamily RECT} statement draws a filled rectangle in graphics mode in a
given color.  The first two arguments are the x and y coordinates for the upper
left corner of the rectangle.  The third and fourth arguments are the x and y
coordinates for the lower right corner of the rectangle.  The fifth argument is
a number from 0-255 that specifies the color from the current palette.\\

Example:\\

\codeblock{
	10 SCREEN \$80\\
	20 FOR Y=0 TO 15\\
	30 FOR X=0 TO 15\\
	40 C=Y*16+X\\
	50 X1=X*20\\
	60 Y1=Y*15\\
	70 RECT X1,Y1,X1+19,Y1+14,C\\
	80 NEXT X,Y\\
}

The above program displays the default VERA color palette to the graphics
screen by drawing a 20x15 rectangle for each color.\\

The {\ttfamily RECT} statement is similar to the {\ttfamily FRAME} statement,
except that {\ttfamily RECT} fills the rectangle with the specified color.

\subsection{REM}

The {\ttfamily REM} statement is used to leave a {\ttfamily REM}ark (also
called a comment) in a BASIC program to help a programmer annotate sections of
the program.  It could help explain how a complex section of logic works, tell
which variable is being used for, or even to let the programmer sign their
name!  A {\ttfamily REM} statement can be followed by anything at all, and the
BASIC program will ignore it.\\

No program needs {\ttfamily REM} statements to function correctly, but they can
make a huge difference when it comes to reading and modifying a BASIC program.
Most programmers will use {\ttfamily REM} statements on any program once it has
become large or complex.  It's a good idea to get into the habit of leaving
comments in your program to help understand how it works.\\

Example:\\

\codeblock {
	10 REM START OF PROGRAM\\
	20 PRINT "ENTER A NUMBER";\\
	30 INPUT A: REM STORE NUMBER IN A\\
	40 PRINT "ENTER ANOTHER NUMBER";\\
	50 INPUT B: REM STORE NUMBER IN B\\
	60 C=A*B: REM MULTIPLY NUMBERS\\
	70 PRINT C\\
}

\subsection{RESTORE}

The {\ttfamily RESTORE} statement resets where the {\ttfamily READ} statement
will read from, causing the next {\ttfamily READ} to read from the first
{\ttfamily DATA} statement again.  In this way, a program can re-read data that
it has already read.  The {\ttfamily RESTORE} statement takes no arguments, and
always directs the next {\ttfamily READ} back to the first {\ttfamily DATA}
statement.\\

Example:\\

\codeblock{

	10 READ A\$\\
	20 PRINT A\$\\
	30 READ A\$\\
	40 PRINT A\$\\
	50 RESTORE\\
	60 READ A\$\\
	70 PRINT A\$\\
	80 DATA "FIRST","SECOND"\\

}

Despite the above program {\ttfamily READ}ing three times yet only having
enough data for two reads, it runs without error because {\ttfamily RESTORE}
causes the first piece of data to be read twice.\\

\subsection{RETURN}

The {\ttfamily RETURN} statement is always used in conjunction with the
{\ttfamily GOSUB} statement.  When a program encounters a {\ttfamily RETURN}
statement, the program immediately jumps to the statement after the last
executed {\ttfamily GOSUB} statement.  During execution, BASIC keeps track of
which {\ttfamily GOSUB} statement has been called in which order.  When a
{\ttfamily RETURN} is executed, the corresponding {\ttfamily GOSUB} is removed
from the list BASIC keeps track of.  Because of this list (often called a
\emph{call stack}) that BASIC keeps track of, programmers are able to
\emph{nest} {\ttfamily GOSUB} statements, so that one subroutine calls another
subroutine and so on.  If the program ever encounters a {\ttfamily RETURN}
statement when its list of {\ttfamily GOSUB}s is empty, it will cause a
{\ttfamily RETURN WITHOUT GOSUB ERROR}.\\

Example:\\

\codeblock{

	10 PRINT "FIRST"\\
	20 GOSUB 50\\
	30 PRINT "FOURTH"\\
	40 END\\
	50 GOSUB 80\\
	60 PRINT "THIRD"\\
	70 RETURN\\
	80 PRINT "SECOND"\\
	90 RETURN\\

}

\subsection{RING}

The {\ttfamily RING} statement draws an unfilled oval in graphics mode in a
given color.  The first two arguments are the x and y coordinates for the upper
left corner of the bounding rectangle that contains the oval.  The third and
fourth arguments are the x and y coordinates for the lower right corner of the
bounding rectangle.  The oval itself will be drawn as an ellipse that fits just
inside the specified bounding rectangle.  The fifth argument is a number from
0-255 that specifies the color from the current palette.\\

Example:\\

\codeblock{
	10 SCREEN \$80\\
	20 FOR C=0 TO 68\\
	30 X=C*4\\
	40 R=X*π*2/128\\
	50 Y=95+SIN(R)*25\\
	60 RING X,Y,X+50,Y+50,C\\
	70 NEXT C\\
}

The {\ttfamily RING} statement is similar to the {\ttfamily OVAL} statement,
except that {\ttfamily OVAL} fills the ellipse with the specified color.

\subsection{SCREEN}

The {\ttfamily SCREEN} statement is used to select a screen mode.  The screen
mode determines how many characters can fit on the screen (both horizontally
and vertically), whether the screen has a border, and whether bitmap graphics
can be rendered in the layer behind the text.  The {\ttfamily SCREEN} statement
requires a numeric argument to tell it which screen mode to use.\\

The available screen modes are:\\

\begin{tabular}{|c|c|p{0.4\linewidth}|}
	\hline
	{\bfseries Decimal} & {\bfseries Hexadecimal} & {\bfseries Screen Mode}\\ \hline
	{\ttfamily 0} & {\ttfamily \$00} & 80x60 Text\\ \hline
	{\ttfamily 1} & {\ttfamily \$01} & 80x30 Text\\ \hline
	{\ttfamily 2} & {\ttfamily \$02} & 40x60 Text\\ \hline
	{\ttfamily 3} & {\ttfamily \$03} & 40x30 Text\\ \hline
	{\ttfamily 4} & {\ttfamily \$04} & 40x15 Text\\ \hline
	{\ttfamily 5} & {\ttfamily \$05} & 20x30 Text\\ \hline
	{\ttfamily 6} & {\ttfamily \$06} & 20x15 Text\\ \hline
	{\ttfamily 7} & {\ttfamily \$07} & 22x23 Text /w border\\ \hline
	{\ttfamily 8} & {\ttfamily \$08} & 64x50 Text /w border\\ \hline
	{\ttfamily 9} & {\ttfamily \$09} & 64x25 Text /w border\\ \hline
	{\ttfamily 10} & {\ttfamily \$0A} & 32x50 Text /w border\\ \hline
	{\ttfamily 11} & {\ttfamily \$0B} & 32x25 Text /w border\\ \hline
	{\ttfamily 128} & {\ttfamily \$80} & 256 color Bitmap Graphics /w 40x30 Text\\ \hline
\end{tabular}

In addition to the above table, the value {\ttfamily -1} can be passed to
{\ttfamily SCREEN} to toggle between modes {\ttfamily 0} and {\ttfamily 3}.\\

\note {

	Other screen configurations can be used by directly setting registers in
	the VERA graphics module.  For more details, see the chapter on Graphics.

}

\subsection{SLEEP}

The {\ttfamily SLEEP} statement pauses program execution for a specified time
period.  The {\ttfamily SLEEP} statement takes a single argument which is the
number of VSYNC interrupts to wait before continuing program execution.  These
interrupts occur approximately 60 times per second, so to have a program wait
for one second, an argument of {\ttfamily 60} would be used.  This unit of
measurement is often called a \emph{jiffy}.  The {\ttfamily SLEEP} statement
will wait for the specified number of jiffies, starting after the next VSYNC
interrupt to occur.  Using {\ttfamily SLEEP} with no arguments is the same as
using {\ttfamily 0} for the number of jiffies, and will cause the program to
wait until the next VSYNC interrupt.  This can be useful for animating
graphics, since a VSYNC interrupt is how you know that the VERA graphics module
is about to start drawing the next frame to the screen.\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries SLEEP 60}&Wait for about one second.\\\\

	{\ttfamily\bfseries SLEEP 600}&Wait for about ten seconds.\\\\

	{\ttfamily\bfseries SLEEP 0}&Wait until the next frame.\\\\

\end{tabular}

\subsection{SPRITE}

The {\ttfamily SPRITE} statement enables or disables one of the VERA's 128
hardware sprites, and allows you to set other sprite properties as well.  The
{\ttfamily SPRITE} statement can cause a hardware sprite to display, but it
cannot tell the sprite what to look like.  For that reason, the {\ttfamily
SPRITE} statement is intended to be used alongside the {\ttfamily SPRMEM}
statement to point a hardware sprite to a VRAM location, and some way to load
data into VRAM (such as the {\ttfamily VLOAD} or {\ttfamily BVLOAD}
statements).\\

However, there is still an easy way to test the {\ttfamily SPRITE} statement
without loading anything into VRAM.  This can be done by using the {\ttfamily
MOUSE} statement, which will initialize hardware sprite 0 to point to VRAM data
initialized to a mouse cursor:\\

\codeblock {
	10 MOUSE 1 : REM TURN ON MOUSE\\
	20 MOUSE 0 : REM TURN OFF MOUSE\\
	30 SPRITE 0,3 : REM DISPLAY SPRITE 0\\
}

The above code will cause the mouse cursor to display, even when the mouse is
not active.  The cursor will not be able to be moved.  This works by enabling
the mouse and initializing sprite 0 with the {\ttfamily MOUSE 1} statement,
disabling the mouse and sprite 0 with {\ttfamily MOUSE 0}, and then
re-displaying sprite 0 (without enabling the mouse) with {\ttfamily SPRITE
0,3}.\\

The first argument to the {\ttfamily MOUSE} statement is the hardware sprite
index.  With 128 hardware sprites, this number can be from 0 to 127.  The
second argument sets the layer the sprite renders to, including disabling the
sprite completely with 0.  The third argument is the palette offset used in 4
bits-per-pixel mode.  The fourth argument sets how the sprite is flipped.  The
fifth argument is used to set width of the sprite, and the sixth sets the
height.  Finally, the seventh argument sets the color mode.  Only the first two
arguments are required.  With this in mind, the sprite from the above program
can be modified.  For example, it can be easily flipped upside down:\\

\codeblock {
	SPRITE 0,3,0,2\\
}

Here is a brief summary of each argument:\\

\begin{tabular}{|c|p{0.7\linewidth}|}
	\hline

	Argument & {\bfseries Description}\\ \hline

	Index & The index of the hardware sprite (0-127)\\ \hline

	Priority & 0 - disable sprite, 1 - draw beneath both VERA
	layers, 2 - draw in between VERA layers, 3 - draw on top of both VERA
	layers\\ \hline

	Palette Offset  & 0-15 in 4bbp mode, not used in 8bpp mode\\ \hline

	Flip & 0 - no flip, 1 - flipped on the x-axis, 2 - flipped on
	the y-axis, 3 - flipped on both x and y axis\\ \hline

	Width & 0 - 8 pixels, 1 - 16 pixels, 2 - 32 pixels, 3 - 64
	pixels\\ \hline

	Height & 0 - 8 pixels, 1 - 16 pixels, 2 - 32 pixels, 3 - 64
	pixels\\ \hline

	Color Mode & 0 - 4bpp, 1 - 8bpp\\ \hline

\end{tabular}

\subsection{SPRMEM}

The {\ttfamily SPRMEM} statement sets the VRAM address and the color mode of a
given sprite.  The first argument is the sprite index.  The VRAM address is
specified in two parts: the bank, and the address within the bank.  The VERA's
128KB of video memory (or VRAM) can be thought of as two banks of 64KB.  The
bank value can either be a 0 to indicate the first 64KB, or a 1 to indicate the
second 64KB.  The address within the bank can then be specified with a 16 bit
integer value.  It is easiest to specify address values using hexadecimal, so
an address within a bank can be any value from \$0000 through \$FFFF.\\

The final argument is the color mode.  The VERA only allows sprites to use the
four bits per pixel mode (4bpp) or the eight bits per pixel mode (8bpp).  A
value of {\ttfamily 0} specifies 4bpp mode, and a value of {\ttfamily 1}
specifies 8bpp.\\

Example:\\

\codeblock{

	10 SCREEN \$80
	20 BVLOAD "MYSPRITE.BIN",8,1,\$3000\\
	30 SPRMEM 1,1,\$3000,1\\
	40 SPRITE 1,3,0,0,3,3\\
	50 MOVSPR 1,160,120\\

}

The above program will load a sprite into VRAM bank 1 at address \$3000
(sometimes specified as address \$13000), set sprite 1 to use that address, and
interpret the data there in 8bpp mode.  The {\ttfamily SPRITE} statement is
then use to set the rest of the sprite's attributes, and the {\ttfamily
MOVESPR} statement moves the sprite's location on the screen.\\

\subsection{STEP}

The {\ttfamily STEP} statement is used with the {\ttfamily FOR}, {\ttfamily
TO}, and{\ttfamily NEXT} statements in order to construct for-loops.  The
{\ttfamily STEP} statement is followed by a number that will be added to the
loop counter variable each time the {\ttfamily NEXT} statement is executed.
This number can be positive or negative.  Both integer and floating point
numbers are allowed.  When no {\ttfamily STEP} statement is used in a for-loop,
a default value of {\ttfamily 1} is used.\\

Examples:\\

\begin{tabular}{l p{0.65\linewidth}}

	{\ttfamily\bfseries FOR I=1 TO 10 STEP 1}&Count from 1 to 10.\\\\

	{\ttfamily\bfseries FOR I=1 TO 10}&Count from 1 to 10 (use default {\ttfamily STEP}).\\\\

	{\ttfamily\bfseries FOR I=2 TO 10 STEP 2}&Count to 10 by 2.\\\\

	{\ttfamily\bfseries FOR I=10 TO 1 STEP -1}&Count backwards from 10.\\\\

	{\ttfamily\bfseries FOR I=0 TO 10 STEP 0.5}&Count by {\ttfamily 0.5}.\\\\

\end{tabular}

\subsection{STOP}

The {\ttfamily STOP} statement will halt a program.  This can be used to help
debug programs by causing them to stop at a certain point, and then {\ttfamily
PRINT}ing the values of variables.  A {\ttfamily STOP}ped program can be
continued by using the {\ttfamily CONT} command, which will start running the
program from the line after the {\ttfamily STOP} statement.\\

When the {\ttfamily STOP} statement executes, it will not only stop the
program, but will also print a message, {\ttfamily BREAK IN xxxx} where
{\ttfamily xxxx} is the line number containing the {\ttfamily STOP} statement.
This is useful when multiple {\ttfamily STOP} statements are used in a single
program.\\

Example:\\

\codeblock{

	10 PRINT "HELLO"\\
	20 STOP\\
	30 PRINT "WORLD"\\

}

Try {\ttfamily CONT}inuing the above program after the {\ttfamily STOP}
statement halts the program.\\

\subsection{SYS}

The {\ttfamily SYS} statement transfers control of the X16 to a machine
language program in memory.\\

Example:\\

\codeblock{
	SYS 8192\\
}

In the above example, the X16 will execute a machine language program stored at
address 8192 in decimal.  Because the Commander X16 also supports hexadecimal
arguments to BASIC statements, the same can be written as:\\

\codeblock{
	SYS \$2000\\
}

\subsection{THEN}

The {\ttfamily THEN} statement is used with an {\ttfamily IF} statement to tell
the program what to do when the condition of the {\ttfamily IF} statement is
{\ttfamily TRUE}.  A {\ttfamily THEN} statement can either be followed by a
line number a BASIC expression such as a variable assignment or another
statement.  If the {\ttfamily THEN} statement is followed by a line number, the
{\ttfamily THEN} statement will behave the same as a {\ttfamily GOTO} statement
and jump program control to the specified line number.  When {\ttfamily THEN}
is followed by a BASIC expression it will execute that expression and then
proceed to the next line of the program.\\

Examples:\\

\codeblock {

	10 A = 5\\
	20 B = 1\\
	30 IF A = 5 THEN B = 2\\
	40 PRINT B\\

}

The above program should print {\ttfamily 2} to the screen instead of
{\ttfamily 1}.  Here is a way to accomplish the same thing by using a line
number with {\ttfamily THEN} instead of an expression.\\

\codeblock {

	10 A = 5\\
	20 B = 1\\
	30 IF A <> 5 THEN 50\\
	40 B = 2\\
	50 PRINT B\\

}

\subsection{TILE}

The {\ttfamily TILE} statement can be used to place a given tile on the VERA's
layer 1 tile map.  This works even when the map base or map size has been
changed, which makes it simple to place tiles in graphics modes.  Because a
text layer on the VERA is just a tile map that uses tile characters, the
{\ttfamily TILE} statement can be used instead of using {\ttfamily LOCATE} and
{\ttfamily PRINT} to place a single character anywhere on the screen.  The
first two arguments to the {\ttfamily TILE} statement are the 0-based X and Y
coordinates, and the third argument is the tile number.\\

Example:\\

\codeblock{

	10 I=0\\
	20 FOR Y=0 TO 15\\
	30 FOR X=0 TO 15\\
	40 TILE X,Y,I\\
	50 I=I+1\\
	60 NEXT:NEXT\\
	70 LOCATE 17 :REM MOVE READY PROMPT DOWN\\

}

The above example uses the {\ttfamily TILE} statement to display all the
characters (the default tile set) on a 16 by 16 grid.\\

\subsection{TO}

The {\ttfamily TO} statement is used with the {\ttfamily FOR} statement, the
{\ttfamily NEXT} statement, and sometimes the {\ttfamily STEP} statement to
create a for-loop.  The {\ttfamily TO} statement is used to define the range of
a for-loop.  The number preceeding the {\ttfamily TO} statement will be the
value of the loop variable on the first pass through the loop, and the loop
will stop when the loop variable is greater than or equal to the number that
follows the {\ttfamily TO} statement.\\

See the {\ttfamily FOR} statement for examples of using the {\ttfamily TO}
statement.\\

\subsection{VPOKE}

The {\ttfamily VPOKE} statement sets a single byte of video RAM (VRAM) on the
VERA's onboard memory.  This allows for directly setting the data that will be
interpretted as graphics and PSG sound.  The VERA has a total of 131,072 bytes
(128 kilobytes) of VRAM, which it exposes as 2 banks of 65,536 bytes (64
kilobytes) each.  The {\ttfamily VPOKE} statement takes three arguments: the
bank, the memory location within the bank, and the value to be stored.\\

Example:\\

\codeblock{

	10 FOR I=1 TO 256*64 STEP 2\\
	20 VPOKE 1,\$B000+I,0 :REM SET COLOR\\
	30 NEXT I\\

}

The above BASIC program will fill the screen with black spaces one character at
a time by writing directly to the area of the VERA's VRAM where the X16 stores
the text mode screen data.  The {\ttfamily VPOKE} sets the background and
forground color to black, although the character data does not change.\\

\note{

	In screen mode 0, the tile map is stored in the VERA at VRAM address
	\$1B000, and is 128 tiles wide by 64 tiles tall.

}

\subsection{VLOAD}

The {\ttfamily VLOAD} statement loads a file with a two-byte header directly
into the VERA's VRAM, but without loading the header.  For arguments, the
{\ttfamily VLOAD} statement takes the file's name, the device number where the
file is stored, the bank of VRAM on the VERA (either {\ttfamily 0} or
{\ttfamily 1}), and the address within the bank in which to load.\\

Examples:\\

\begin{tabular}{l p{0.35\linewidth}}

	{\ttfamily\bfseries VLOAD "MYFILE.BIN",8,0,\$4000}&Loads a file named
	"MYFILE.BIN" from device 8 into VRAM at address \$04000.\\\\

	{\ttfamily\bfseries VLOAD "MYFONT.BIN",8,1,\$F000}&Loads a file named
	"MYFONT.BIN" from device 8 into VRAM at address \$1F000.\\\\

\end{tabular}

To load a file that does not have a two-byte header, see the {\ttfamily BVLOAD}
statement.\\

\subsection{WAIT}

The {\ttfamily WAIT} statement is used to halt a program until the contents of
a memory location changes in a specified way.  The {\ttfamily WAIT} statement
requires an memory address as the first argument, and a value for the second.
When the value in the memory address is {\ttfamily AND}ed with the second
argument and results in a zero, the {\ttfamily WAIT} statement continues to
halt the program while it keeps re-checking the memory address.  When the
result is non-zero, the program continues.  An optional third argument can be
supplied that will be logically {\ttfamily XOR}ed to the value in memory before
being {\ttfamily AND}ed by the second argument.\\

The {\ttfamily WAIT} statement is not very useful for most BASIC programs, and
is typically only used when interfacing with hardware via memory mapped
addresses.\\

Example:\\

(\emph{When executing this program, continue to hold
\keybackgroundcolor{gray}\keytextcolor{black}\widekey{return} after typing
{\ttfamily RUN}})\\

\codeblock{

	10 BANK 0\\
	20 PRINT "LET GO OF RETURN KEY"\\
	30 WAIT \$A820,16\\
	40 PRINT "PRESS RETURN KEY"\\
	50 WAIT \$A820,16,16\\
	60 GOTO 20\\

}

The above example works by reading the memory location of the X16's "joystick
0", which is a virtual joystick emulated with the keyboard".  The first
{\ttfamily WAIT} is used to detect that \widekey{return} is no longer pressed
(which it would be after executing the {\ttfamily RUN} command), and the second
detects that it has been pressed again\footnote{The use of {\ttfamily WAIT}
here is just for an example.  The {\ttfamily JOY} function would be a much
better choice for this functionality}.\\

\section{Functions}

\emph{Functions} are instructions that return values that can be used like
variables, or even assigned to variables.  Functions are often called in-line
to supply arguments to statements.  Functions will either return a numeric
value or a string value.  If the function returns a string value, its name will
end with a {\ttfamily \$}.\\

Because the return value is a fundamental property of a function, many of the
examples in this section include the output of the example listed directly
below the example, itself.\\

\subsection{ABS}

The {\ttfamily ABS(X)} function will return the absolute value of {\ttfamily
X}.\\

Example:\\

\codeblock{

	PRINT ABS(-10)\\
	\hspace*{0.6em}10\\

}

\subsection{ASC}

The {\ttfamily ASC} function will return an integer value representing the
PETSCII code\footnote{See the PETSCII Codes table in the appendix} for the
first character of string.  If string is the empty string, {\ttfamily ASC}
returns 0.  The opposite of this function is the {\ttfamily CHR\$} function.\\

Example:\\

\codeblock{

	PRINT ASC("A")\\
	\hspace*{0.6em}65\\

}

\subsection{ATN}

The {\ttfamily ATN(X)} (arctangent) function will return the angle whose
tangent is {\ttfamily X}.  This is the inverse of the {\ttfamily TAN}
function.\\

Example:\\

\codeblock{

	PRINT ATN(0)\\
	\hspace*{0.6em}0\\

}

In the above example, the value 0 will be printed on the screen.\\

\subsection{BIN\$}

The {\ttfamily BIN\$} function returns a string of the binary representation
(1's and 0's) of a number.  The {\ttfamily BIN\$} function will only work on
numbers greater than or equal to 0, and less than 65,536.  When a floating
point number number is passed to {\ttfamily BIN\$}, it will ignore the decimal
part of the number and truncate the value to an integer, just as the {\ttfamily
INT} function does.  When {\ttfamily BIN\$} is passed a number that is less
than 256, it only returns 8 characters since the value can be represented by 8
bits.  When a number that is 256 or greater is used, it will return 16
characters.\\

Examples:\\

\codeblock{

	PRINT BIN\$(3)\\
	00000011\\

	PRINT BIN\$(3.14)\\
	00000011\\

	PRINT BIN\$(3000)\\
	0000101110111000\\

}

\subsection{CHR\$}

The {\ttfamily CHR\$} function takes a number from 0-255 and returns the
PETSCII character represted by that PETSCII code\footnote{See the PETSCII Codes
table in the appendix}.  Floating point numbers will be truncated to integers,
as is done when the {\ttfamily INT} function is used.  Numbers outside that
range will cause an error.  The opposite of this function is the {\ttfamily
ASC} function.\\

Examples:\\

\codeblock{

	PRINT CHR\$(65)\\
	A\\

	PRINT CHR\$(65.7)\\
	A\\

	PRINT CHR\$(147) : REM CLEARS SCREEN\\

}

\subsection{COS}

The {\ttfamily COS(X)} (cosine) function will return the cosine of an angle
{\ttfamily X}, measured in radians.\\

Example:\\

\codeblock{

	PRINT COS(π)\\
	\hspace*{1em}-1\\

}

\subsection{EXP}

The {\ttfamily EXP(X)} (exponent) function will return the value of the
mathematical constant {\ttfamily e} (2.71828183) raised to the power of
{\ttfamily X}.\\

Examples:\\

\codeblock{

	PRINT EXP(5)\\
	\hspace*{0.6em}148.413159\\

	REM PRINT E, ITSELF\\
	PRINT EXP(1)\\
	\hspace*{0.6em}2.71828183\\

}

\subsection{FNXX(X)}

Any function {\ttfamily FNXX} (where {\ttfamily XX} is any legal name) that has
been defined with the {\ttfamily DEF} statement can be called inside or outside
of a BASIC program.  It will execute the user-defined function and return the
result.\\

See the {\ttfamily DEF} statement for details and examples.\\

\subsection{FRE}

The {\ttfamily FRE} function returns the number of unused (or {\em free}) BASIC
bytes.  Although the {\ttfamily FRE} function requires an argument (any valid
numeric or string will do), this argument has no effect on the function's
result.\\

Example:\\

\codeblock{

	10 PRINT FRE(0)\\
	20 DIM A(4096) :REM ALLOCATE SOME MEMORY\\
	30 PRINT FRE(0)\\

}

The above program will print the amount of free memory available to BASIC,
allocate some of that memory, and then again print the updated amount of free
memory.\\

\subsection{HEX\$}

The {\ttfamily HEX\$} function takes a numeric value and returns a string of
the {\em hexadecimal} representation of that value.  Hexadecimal is a base-16
number system, meaning that 16 different numeric values can be represented by a
single character.  Just like with the usual base-10 number system, or {\em
decimal}, when the next highest value is needed you simply use more than one
character to represent it.  For example, in decimal when the value 10 needs to
be written, two characters are used: "1" followed by "0".\\

In order to have 16 different characters to represent numeric values,
alphabetic characters are used for values 10 through 15.  Here are the
characters used in hexadecimal, and their decimal equivalents:\\

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	{\bfseries H} & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & A & B & C & D & E & F \\ \hline
	{\bfseries D} & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 \\ \hline
\end{tabular}

\vspace{16pt}

So in order to write the value 16 in hexadecimal, two characters would need to
be used: "1" followed by "0" (just like 10 in decimal).\\

The {\ttfamily HEX\$} function can accept any numeric value from 0-65535.  When
values less than 256 are given, {\ttfamily HEX\$} always returns exactly two
characters, and when values greater than or equal to 256 are given, it always
returns 4 characters.  Both are padded with 0's if necessary.\\

Example:\\

\codeblock {

	10 FOR I=0 to 50\\
	20 PRINT I,HEX\$(I)\\
	30 NEXT I\\

}

The above program will print out a table showing values in decimal followed by
the same value in hexadecimal.\\

\subsection{INT}

The {\ttfamily INT} function returns a truncated\footnote{{\em Truncated} means
removing all decimal places to the right of the decimal point, leaving only an
integer} integer version of the numeric argument passed to the function.  The
result will always be less than or equal to the argument, including when the
argument is negative.\\

Examples:\\

\codeblock {
	PRINT INT(3.8)\\
	\hspace*{0.6em}3\\

	PRINT INT(-3.8)\\
	\hspace*{1em}-4\\
}

The {\ttfamily INT} function can also be used to round decimal numbers to a
certain precision, such as to the nearest hundredth:\\

\codeblock {
	X=INT(X*100+0.5)/100\\
}

\subsection{I2CPEEK}

The {\ttfamily I2CPEEK} function returns a value from a register of an
I\textsuperscript{2}C device.  The first argument is the device and the second
argument is the register.\\

Example:\\

\codeblock {
	10 REM DISPLAY SECONDS FROM RTC\\
	20 CLS\\
	30 S=I2CPEEK(\$6F,0)\\
	40 PRINT HEX\$(S AND \$7F)\\
	50 SLEEP 0:REM WAIT FOR NEXT VSYNC\\
	60 GOTO 20\\
}

\subsection{LEFT\$}

The {\ttfamily LEFT\$} function takes a string and number and returns a
substring containing the specified number of leftmost characters.\\

Example:\\

\codeblock {
	PRINT LEFT\$("BASEBALL", 4)\\
	BASE\\
}

\subsection{LEN}

The {\ttfamily LEN} function returns the length of a string.  Because a string
in BASIC can never exceed a length of 255 characters, the {\ttfamily LEN}
function will always return values between 0-255.\\

Example:\\

\codeblock {
	PRINT LEN("COMMANDER X16")\\
	\hspace*{0.6em}13\\
}

\subsection{LOG}

The {\ttfamily LOG} function will return the natural log of the given numeric
value.  The natural log is the log to the base of {\ttfamily e} (see {\ttfamily
EXP}).  To convert to log base 10, simply divide by {\ttfamily LOG(10)}.  To
convert to log base 2, divide by {\ttfamily LOG(2)}.\\

Examples:\\

\codeblock{

	REM NATURAL LOG OF 8\\
	PRINT LOG(8)\\
	\hspace*{0.6em}2.07944154\\

	REM LOG BASE 10 OF 8\\
	PRINT LOG(8)/LOG(10)\\
	\hspace*{0.6em}.903089987\\

	REM LOG BASE 2 OF 8\\
	PRINT LOG(8)/LOG(2)\\
	\hspace*{0.6em}3\\

}

\subsection{MID\$}

The {\ttfamily MID\$} function takes a string, a start position, and an
optional number of characters, and returns a substring of the original string.
The substring begins with the character specified by the start position, and
will be as long as is specified by the number of characters.  If the number of
characters is not specified, the substring will contain all characters up to
the end of the original string.\\

Examples:\\

\codeblock {

	PRINT MID\$("COMMANDER X16",4,3)\\
	MAN\\

	PRINT MID\$("COMMANDER X16",1,3)\\
	COM\\

	PRINT MID\$("COMMANDER X16",7,5)\\
	DER X\\

	PRINT MID\$("COMMANDER X16",11)\\
	X16\\
}

\subsection{PEEK}

The {\ttfamily PEEK} function returns the contents of the Commander X16's
memory at a given address.  This includes reading the values from any of the
X16's memory mapped hardware devices (if they are readable) such as the VERA or
the FM synthesizer chip.  The address must be in the range of 0-65535, and the
values returned will all be in the range of 0-255.\\

Example:\\

\codeblock {
	10 FOR A=0 TO 255\\
	20 PRINT HEX\$(A)+": \$";\\
	30 PRINT HEX\$(PEEK(A)),;\\
	40 NEXT A\\
}

The above example will print the entire contents of the zero page\footnote{The
"zero page" is the first 256 bytes of the Commander X16's memory.  This memory
has special purposes on the 65C02 processor.}.\\

\subsection{POINTER}

The {\ttfamily POINTER} function returns the memory address of the data
structure where a BASIC variable is stored.\\

\codeblock {

	10 X\$ = "COMMANDER X16"\\
	20 PRINT HEX\$(POINTER(X\$))\\
}

\subsection{POS}

The {\ttfamily POS} function returns the current column of the text cursor.
The {\ttfamily POS} function takes a single argument that is unused.  Due to
the way BASIC reads data from a program, the fastest type of variable to use is
the special constant {\ttfamily π} (pi).  Therefore, it is a common convention
to always call the {\ttfamily POS} function as {\ttfamily POS(π)}.\\

\codeblock {
	10 PRINT POS(π)\\
	20 REM ADVANCE THE COLUMN BUT NOT THE LINE\\
	30 PRINT "COMMANDER X16";\\
	40 PRINT POS(π)\\
}

\subsection{RIGHT\$}

The {\ttfamily RIGHT\$} function takes a string and number and returns a
substring containing the specified number of rightmost characters.\\

Example:\\

\codeblock {
	PRINT RIGHT\$("BASEBALL", 4)\\
	BALL\\
}

\subsection{RND}

The {\ttfamily RND} function generates pseudo-random floating-point numbers in
the range of 0 to 1 (exclusive), such as 0.153632167, 0.567453436,
0.942242351.\\

At power-on of the X16 computer a sequence of random numbers is generated
automatically and stored.  The number passed in parenthesis to the {\ttfamily
RND} function influences the resulting values in subsequent calls to {\ttfamily
RND}.  A negative number (-1) will reseed the sequence starting point of
original random generated numbers.  The same negative number will result in the
same sequence of random numbers.  A positive number (1) will return the next
random number of the current sequence.  Using a zero (0) will generate a
shorter sequence of random numbers, which can provide a speed improvement in
returning the result (if processing times are important).\\

A best practice method is to initially seed the {\ttfamily RND} function with
{\ttfamily -TI}, at the beginning of your program.  The {\ttfamily TI} system
variable, which stands for Time-Interval, is the elapsed time since your
computer last turned on.  Generally, this provides a different random sequence
every time you re-run the program.  When you need a random number later in your
program you can then use RND(1) to provide the next random number.\\

Using a formula including the {\ttfamily RND(1)} function, can get a random
value between any two numbers.  Using variables to explain this formula,
{\ttfamily LO = 10} and {\ttfamily HI = 40}, the formula could be {\ttfamily N
= RND(1)*(HI-LO)+LO}.  This will result in random numbers between 10 and (less
than) 40. When repeated, you might see numbers like 13.3567377, 24.5913944,
16.2857004, and 39.2262697.\\

\begin{tabular}{l p{0.45\linewidth}}

	{\ttfamily\bfseries X = INT(RND(1)*6)+1} & Simulate a 6-side dice roll\\

	{\ttfamily\bfseries X = INT(RND(1)*1000)+1} & Number from 1-1000\\

	{\ttfamily\bfseries X = INT(RND(1)*150)+100} & Number from 100-249\\

\end{tabular}

\vspace{16pt}

\subsection{RPT\$}

The {\ttfamily RPT\$} function returns a string of repeated PETSCII characters.
Like the {\ttfamily CHR\$} function, the {\ttfamily RPT\$} function takes a
PETSCII code\footnote{See the PETSCII Codes table in the appendix}, but also
takes a second argument indicating a count.  The string returned will be the
character specified by the PETSCII code repeated as many times as the count
indicates.\\

Example:\\

\codeblock{

	PRINT RPT\$(33,10)\\
	!!!!!!!!!!

}

\subsection{SGN}

The {\ttfamily SGN} function returns the sign of a numeric value.\\

Examples:\\

\codeblock{
	
	PRINT SGN(42)\\
	\hspace*{0.6em}1\\

	PRINT SGN(-23.96)\\
	\hspace*{0.1em}-1\\

	PRINT SGN(0)\\
	\hspace*{0.6em}0\\

}

\subsection{SIN}

The {\ttfamily SIN(X)} (sine) function will return the sine of an angle
{\ttfamily X}, measured in radians.\\

Example:\\

\codeblock{

	PRINT SIN(π/2)\\
	\hspace*{0.6em}1\\

}

\subsection{SPC}

The {\ttfamily SPC} function can be used to set a number of spaces, either
printed to the screen or written to a file.  It takes a numeric value for the
number of spaces to use.  The {\ttfamily SPC} function is similar to using the
{\ttfamily RPT\$} function to return a number of spaces, but not equivalent.
The {\ttfamily SPC} function does not return a string, but rather adds the
desired number of spaces directly into the output, whether it be the screen or
a file.  The {\ttfamily SPC} function will not overwrite existing text on the
screen, which is fundamentally different than simply printing a string.
Because of these reasons, the {\ttfamily SPC} function cannot be called except
as part of a {\ttfamily PRINT} statement.\\

When the {\ttfamily SPC} function is used as the last item in a {\ttfamily
PRINT} statement, the carriage return that would normally be inserted is
suppressed, just as it is for trailing commas and semicolons.\\

Examples:\\

\codeblock{
	PRINT SPC(5) "HELLO"\\
	\hspace*{3em}HELLO\\
	
	10 PRINT "HELLO" SPC(5)\\
	20 PRINT "WORLD"\\
	RUN\\
	HELLO\hspace*{3em}WORLD\\
}

\subsection{SQR}

The {\ttfamily SQR} function returns the square root of a non-zero number.  If
the number given is negative, the {\ttfamily SQR} function will return an
{\ttfamily ILLEGAL QUANTITY ERROR}.\\

Examples:\\
 \codeblock{
	 PRINT SQR(9)\\
	 \hspace*{0.6em}3\\
	 PRINT SQR(25.0)\\
	 \hspace*{0.6em}5\\
	 PRINT SQR(48)\\
	 \hspace*{0.6em}6.92820323\\
 }

\subsection{STR\$}

The {\ttfamily STR\$} function converts a numeric value to a string value using
the same methodology as {\ttfamily PRINT}ing a numeric value.  This means that
{\ttfamily 0} and positive numbers converted to strings will begin with a
space, while negative numbers will begin with a {\ttfamily -}.  This means that
string functions such as {\ttfamily LEN} will work properly on the resulting
string, whereas counting the digits could lead to errors in printing.\\

Example:\\

\codeblock {
	PRINT LEN(STR\$(10))\\
	\hspace*{0.6em}3\\
}

\subsection{STRPTR}

The {\ttfamily STRPTR} function returns the memory address of the first
character of a given string variable.  If the string variable passed to
{\ttfamily STRPTR} is empty (has a length of zero), then the value returned by
{\ttfamily STRPTR} is undefined and should not be used.  To prevent using bad
memory, always use the {\ttfamily LEN} function on a string ahead of time to
make sure that it is not empty.\\

Example:\\

\codeblock {
	10 INPUT "ENTER A WORD";A\$\\
	20 IF LEN(A\$) > 0 GOTO 40\\
	30 END\\
	40 P=STRPTR(A\$)\\
	50 PRINT CHR\$(PEEK(P))\\
	RUN\\
	ENTER A WORD? THING\\
	T\\
}

\subsection{TAB}

The {\ttfamily TAB} is used as part of a {\ttfamily PRINT} statement to advance
the cursor to a given column.  If the cursor is already at or beyond the given
column, it simply continues printing from the current position.  The {\ttfamily
SPC} function is usually better to use than the {\ttfamily TAB} function when
inserting spaces in output, especially when the output device is a file or a
printer.  The {\ttfamily TAB} function operates much like the comma ({\ttfamily
,}) in a {\ttfamily PRINT} statement, except it allows the width of the
tabulation to be set with an argument.\\

Example:\\

\codeblock {
	10 FOR I=0 to 10\\
	20 PRINT I TAB(10) I*2 TAB(30) I*3\\
	30 NEXT I\\
}

\subsection{TAN}

The {\ttfamily TAN(X)} (tangent) function will return the tangent of an angle
{\ttfamily X}, measured in radians.\\

Example:\\

\codeblock{

	PRINT TAN(0)\\
	\hspace*{0.6em}0\\

}

\subsection{TATTR}

The {\ttfamily TATTR} function retrieves the tile attribute byte of a given X/Y
coordinate on layer 1 of the VERA.  This attribute carries different
information depending on which screen mode is being used.  This is the same
attribute byte that can be optionally set to the layer 1 tile map with with the
{\ttfamily TILE} statement.\\

Example:\\

\codeblock{

	10 REM SHOW ATTRIBUTE BYTES OF BUTTERFLY LOGO\\
	20 BANNER\\
	30 FOR Y=1 TO 6\\
	40 FOR X=1 TO 6\\
	50 PRINT TATTR(X,Y),;\\
	60 NEXT X\\
	70 PRINT ""\\
	80 NEXT Y\\
}

\subsection{TDATA}

The {\ttfamily TDATA} function retrieves the tile index of the tile used on a
given X/Y coordinate of the layer 1 tile map.  This is the same tile index
value that can be set to the tile map with the {ttfamily TILE} statement.\\

Example:\\

\codeblock{

	10 REM SHOW TILE INDEXES OF BUTTERFLY LOGO\\
	20 BANNER\\
	30 FOR Y=1 TO 6\\
	40 FOR X=1 TO 6\\
	50 PRINT TDATA(X,Y),;\\
	60 NEXT X\\
	70 PRINT ""\\
	80 NEXT Y\\
}

\subsection{USR}

The {\ttfamily USR} function calls a user-defined assembly routine from BASIC.
It can accept any valid BASIC expression as an argument, as long as the
expression resolves to a number or a string.  If the expression is numeric, it
places the result in a special place in memory called the Floating Point
Accumulator (FACC, for short) located from {\ttfamily \$61-\$66}.  From there
the user-defined assembly routine can read the result of the expression as
input.  If the expression evaluates to a string, it places a pointer to the
string located from {\ttfamily \$54-\$65}.  The result of the user-defined
assembly routine must be a floating point placed in the FACC.\\

The address of the user-defined assembly routine to be called should be stored
in the address {\ttfamily \$0311-\$0312} prior to calling the {\ttfamily USR}
function.  Otherwise this address will store the address of an error handler
that displays the {\ttfamily ?ILLEGAL QUANTITY ERROR}.  By using the {\ttfamily
USR} function, any number of built-in or custom assembly routines can be called
from BASIC and used as an expression.\\

Example:\\

\codeblock {
	10 REM SET THE USR FUNCTION TO THE\\
	20 REM FADDH MATH LIBRARY ROUTINE\\
	30 POKE \$0311,\$6F\\
	40 POKE \$0312,\$FE\\
	50 PRINT USR(4.2)\\
}

The above BASIC program will set the user-defined function to the {\ttfamily
FADDH} X16 Math Library routine at address {\ttfamily \$FE65}, which takes a
number in the FACC and adds {\ttfamily 0.5} to it.  The program then calls the
{\ttfamily FADDH} routine with {\ttfamily 4.2} using the {\ttfamily USR}
function.  The program should print a result of {\ttfamily 4.7}.

\subsection{VAL}

The {\ttfamily VAL} function returns a numeric value representing the
characters in a string argument.  Often a string variable is passed to the
function, but a literal string is also valid (eg. "  -540.15 "). Blank
characters ("spaces") in the string are ignored.  If the first non-blank
character of the string is not a plus sign (+), minus sign (-), dollar sign
(\$), percentage sign (\%) or a digit the conversion ends with a value of zero
(0).  These initial special characters signify the type of number to follow -
Positive (+); Negative (-); Hexadecimal (\$), which then validates the letters
A,B,C,D,E \& F; Binary Literal (\%) eg. "010101"; and Numbers (0123456789).
Subsequent valid characters are additional digits (or the first decimal point
or E/e for Exponent).  The function ends at the end of the string, or the next
non-digit character for that numberic type and returns the converted result.
Subsequent digits after any non-valid characters are disregarded.  Other
mathematical terms and arithmetic operations are ignored.\\

The valid range of possible numbers is from -1e+38 to 1e+38. Outside of this
range the error "?OVERFLOW ERROR IN <line>" is shown and the program stops.
When the argument isn't a string, the error "?TYPE MISMATCH ERROR IN <line>"
would result and stop the program.  When the argument is absent, the error
"?SYNTAX ERROR IN <line>" is returned and stops the program.\\

Examples:\\

\codeblock{

	10 READ A\$\\
	20 DATA "  - 120 . 64  "\\
	30 PRINT VAL(A\$)\\
	RUN\\
	\hspace*{1em}-120.64\\
}

Leading letters are invalid, but don't cause an error.\\

\codeblock{

	PRINT VAL("ABC 123")\\
	\hspace*{0.6em}0\\

}

The binary literal string is converted to decimal number.\\

\codeblock{

	PRINT VAL("\%010101")\\
	\hspace*{0.6em}21\\

}

The exponential notation string is returned as a simplified number.\\

\codeblock{

	PRINT VAL("+352 .25 E-3  Units")\\
	\hspace*{0.6em}0.35225\\

}

\subsection{VPEEK}

The {\ttfamily VPEEK} function gets a single byte of vidoe RAM (VRAM) from the
VERA's onboard memory.  The allows a BASIC program to read the data being
interpreted by the VERA to produce graphics and sound.  The {\ttfamily VPEEK}
function takes two arguments: the bank and the memory location within the bank.\\

Example:\\

\codeblock {
	10 FOR I=0 TO 256*64-1\\
	20 PRINT VPEEK(1,\$B000+I),;\\
	30 NEXT I\\
}

The above BASIC program will print out the data being used to display the text
mode screen data, including the attribute data responsible for coloring the
text.\\

\section{System Variables}

\emph{System Variables} are special purpose BASIC variables that are
automatically assigned values by the Commander X16.  Because of this, these
variables cannot be assigned values in BASIC programs or commands.  These
variables provide a convenient way to perform common calculations or read
values from the X16 hardware.\\

\subsection{DA\$}

The {\ttfamily DA\$} system variable returns the current time on the Real Time
Clock (RTC) as a string formatted as YYYYMMDD.\\

Example:\\

\codeblock {
	PRINT DA\$\\
	20240617\\
}

\subsection{MWHEEL}

The {\ttfamily MWHEEL} special variable holds the movement of the mouse wheel
as a value from {\ttfamily -128} to {\ttfamily 127}.  This value represents how
far the wheel has moved since the last time {\ttfamily MWHEEL} was read.  The
value will be negative if the wheel was moved away from the user, and positive
if the wheel was moved towards the user.//

The {\ttfamily MWHEEL} variable will only have a value if the mouse as been
enabled with {\ttfamily MOUSE 1}.

Example:\\

\codeblock {
	10 MOUSE 1:REM ENABLE MOUSE\\
	20 PRINT MWHEEL\\
	30 SLEEP 60:REM WAIT ABOUT A SECOND\\
	40 GOTO 20\\
}

Run the above program and try scrolling the mouse between outputs to the
screen.\\

\subsection{MX/MY}

The {\ttfamily MX} and {\ttfamily MY} special variables hold the current X and
Y position of the mouse cursor.  Unlike the {\ttfamily MWHEEL} variable,
{\ttfamily MX} and {\ttfamily MY} will retain their values even when the mouse
has been disabled with {\ttfamily MOUSE 0}, however the values will not be
updated until the mouse is enabled with {\ttfamily MOUSE 1}.\\

Example:\\

\codeblock {
	10 MOUSE 1:REM ENABLE MOUSE\\
	20 PRINT MX,MY\\
	30 GOTO 20\\
}

Run the above program and move the mouse around.\\

\subsection{MB}

The {\ttfamily MB} system variable holds the states of the 3 mouse buttons by
storing them in a value between {\ttfamily 0} and {\ttfamily 7}.  This value is
a {\emph bitmask}, which means that each bit of its binary representation can
be thought of as an independent boolean value.  In this way, the single integer
value held by {\ttfamily MB} can contain the on/off state of up to eight
buttons.  Since the Commander X16 mouse only has three buttons, only the lowest
three bits are used.  The lowest bit represents the left button, the second
lowest represents the right button, and the third lowest represents the middle
button (pressing down on the scroll wheel):\\

\begin{tabular}{|c|c|c|c|c|c|c|c|}
	\hline

	{\bfseries 7} &{\bfseries 6} &{\bfseries 5} &{\bfseries 4} &{\bfseries 3}
	&{\bfseries 2} &{\bfseries 1} &{\bfseries 0}\\ \hline

	- & - & - & - & - & M & R & L \\ \hline
	
\end{tabular}

\vspace{16pt}

A {\ttfamily 1} on a bit means that the button is currently pressed and a
{\ttfamily 0} means it is not pressed.  The easiest way to see a particular
button is pressed is to {\ttfamily AND} the {\ttfamily MB} value with the value
{\ttfamily MB} would have it only that button were pressed.  If the result is
greater than zero, then the button is currently pressed.  If the result is
equal to zero, it means the that button is {\emph not} currently pressed:\\

\begin{tabular}{|c|c|c|}
	\hline

	{\bfseries Button} & If Pressed & If Not Pressed\\ \hline

	Left & {\ttfamily IF (MB AND 1)>0} & {\ttfamily IF (MB AND 1)=0}\\ \hline
	Right & {\ttfamily IF (MB AND 2)>0} & {\ttfamily IF (MB AND 2)=0}\\ \hline
	Middle & {\ttfamily IF (MB AND 4)>0} & {\ttfamily IF (MB AND 4)=0}\\ \hline

\end{tabular}

\vspace{16pt}

Example:\\

\codeblock {

	10 MOUSE 1:REM TURN ON MOUSE\\
	20 CLS:REM CLEAR SCREEN\\
	30 PRINT MB:REM DISPLAY RAW MB VALUE\\
	40 PRINT BIN\$(MB):REM MB IN BINARY\\
	50 IF (MB AND 1)=0 GOTO 70\\
	60 PRINT "L";\\
	70 IF (MB AND 4)=0 GOTO 90\\
	80 PRINT "M";\\
	90 IF (MB AND 2)=0 GOTO 110\\
	100 PRINT "R";\\
	110 SLEEP 0\\
	120 GOTO 20\\

}

\subsection{\ttfamily π}

The {\ttfamily π} variable holds the value of pi and can be used just like any
other floating point variable or literal.\\

\codeblock {
	10 INPUT "WHAT IS THE RADIUS OF THE CIRLCE";R\\
	20 PRINT "CIRCUMFRANCE:",2*R*π\\
	30 PRINT "AREA:",,R*R*π\\
}

\subsection{ST}

The {\ttfamily ST} system variable holds the status of various input or output
operations, including DOS commands.  The status is stored as a {\emph bitmask},
much like the {\ttfamily MB} system variable, so each bit indicates something
different.  What each bit indicates is determined by the device and operation
executed:\\

\begin{tabular}{|p{0.05\linewidth}|p{0.07\linewidth}|p{0.25\linewidth}|p{0.25\linewidth}|p{0.2\linewidth}|}
	\hline

	{\bfseries ST bit} & {\bfseries Bit-Value} & {\bfseries Datasette} &
	{\bfseries Serial Bus} & {\bfseries RS-232}\\ \hline

	0 & 1 & - & indicates data direction if a timeout occurred; 0 = reading, 1
	= writing & parity error\\ \hline

	1 & 2 & - & timeout error & framing error\\ \hline

	2 & 4 & block was too short (less than 192 bytes) & - & receive buffer overrun\\ \hline

	3 & 8 &  block was too long ( greater than 192 bytes )& - & receive buffer empty\\ \hline

	4 & 16 & {\ttfamily VERIFY} error (erroneous read bytes from pass 1 could
	not read correctly even in pass 2) & {\ttfamily VERIFY} error & CTS signal
	missing\\ \hline

	5 & 32 & checksum error & - & -\\ \hline

	6 & 64 & end of file has been reached (only while reading) & end of file
	has been reached & RTS signal missing\\ \hline

	7 & 128 & - & device not present error & BREAK detected\\ \hline

\end{tabular}

\vspace{16pt}

\subsection{TI}

The {\ttfamily TI} system variable returns the number of "jiffies" since the
Commander X16 was booted.  A "jiffie" is a single refresh cycle of the video
signal, so 1/60\textsuperscript{th} of a second for NTSC video modes.  The
{\ttfamily TI} system variable resets to {\ttfamily 0} at every boot, and once
it reaches a value of {\ttfamily 5183999}, the equivalent of 24 hours worth of
jiffies\footnote{Unlike the Commodore 64, the {\ttfamily TI} variable is {\emph
not} reset when the {\ttfamily TI\$} system variable is set}.\\

Example:\\

\codeblock{
	PRINT TI
}

\subsection{TI\$}

The {\ttfamily TI\$} system variable returns a string value of the current time
according to the Real Time Clock (RTC)\footnote{Unlike the Commodore 64, the
{\ttfamily TI\$} variable cannot be set.  However, the value of the RTC can be
set, and the value of {\ttfamily TI\$} will be updated accordingly}.  The value
of the {\ttfamily TI\$} system variable is in the HHMMSS format, where HH is a
value from "00" through "23" and MM and SS are both values from "00" through
"59".\\

Example:\\

\codeblock{
	PRINT TI\$
}
