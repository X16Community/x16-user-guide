\chapter{Commander X16 BASIC}

This manual has introduced you to the BASIC language and many of the commands,
operators, and conventions.  However, that is not enough in order to truly
understand how to use BASIC.  This appendix is a reference that aims to provide
a complete documentation for Commander X16 BASIC.  It will provide the rules
(known as \emph{syntax}) of the BASIC language, and concise descriptions of
each BASIC command.\\

To make this information easier to read, it is broken up into the following
sections:\\

\begin{enumerate}

	\item {\bfseries Variables}: describes what variables are, the different
		types of variables, and the allowed variable names.

	\item {\bfseries Operators}: describes arithmetic and logical operators.

	\item {\bfseries Commands}: describes the interactive commands that are
		used to work with programs or perform other tasks that users typically
		type directly into the {\ttfamily READY} prompt.

	\item {\bfseries Statements}: describes the statements that are typically
		used in BASIC programs, but aren't often called directly by users from
		the {\ttfamily READY} prompt.

	\item {\bfseries Functions}: describes the BASIC functions that return
		values, such as calculations and string operations.

\end{enumerate}

\vspace{16pt}

\note{

	Commands and statements are not technically different, and often these
	terms are used interchangeably.  Commands can be used from within BASIC
	programs and statements can be run directly from the {\ttfamily READY}
	prompt.  The reason for different labels is because many commands make
	little sense when used from within BASIC programs.  For example, using the
	{\ttfamily NEW} command inside a BASIC program will cause the program to
	halt execution and be removed from memory!

}

\section{Variables}

Variables are values that have been given names.  Programs use variables for
many purposes, and they are an important part of BASIC programming.
Programmers can \emph{assign} a value to a variable, and then use that value
later in their program by referring to the variable.  For example:\\

\codeblock{
	10 T\$ = "X16"\\
	20 PRINT T\$\\
}

The above BASIC program stores the value {\ttfamily "X16"} in a variable named
{\ttfamily T\$}, and then {\ttfamily PRINT}s the value of {\ttfamily T\$} to
the screen.\\

Variables are similar to memory addresses except for a couple of key
differences.  First, the programmer doesn't have to keep track of where a
variable is stored in the Commander X16's memory.  This job is performed by
BASIC to make the programmer's job easier.  Second, variables have a
\emph{type}.  There are three types of variables in Commander X16 BASIC.  The
three types of variables are: \emph{floating point}, \emph{integer numeric},
and \emph{string (alphanumeric)} variables.\\

\subsection{Floating Point Variables}

\emph{Floating point numeric variables} can have any value from $-10^{38}$ to
$10^{38}$, with up to nine digits of accuracy.  Floating point values can hold
partial values, such as $3.4$, $42.7$, or $0.000025$.  This makes them useful
for a variety of mathematical uses.  Floating point variables can be named with
any single letter, any letter followed by a number, or with two
letters\footnote{There are three variable names that are \emph{reserved} by the
Commander X16 for its own use, and cannot be used for variable names in your
programs.  These names are {\ttfamily ST}, {\ttfamily TI}, {\ttfamily TI\$},
and {\ttfamily DA\$}}.  For example, {\ttfamily A}, {\ttfamily A5}, or
{\ttfamily AB}.\\

To assign a floating point variable, type your chosen name for the variable
followed by an {ttfamily =} and then the value you wish to assign it:\\

\codeblock{
	A = 3.4\\
	A5 = 42.7\\
	AB = 0.000025\\
}

For numbers that are very large or very small, you may wish to use scientific
notation to assign your variables.  The Commander X16 understands scientific
notation by using the letter {\ttfamily E} to separate the coefficient from the
exponent (the base is always assumed to be $10$).  So to assign the value $3.7
\times 10^{-14}$ to a floating point variable named {\ttfamily B2}, you would
type:\\

\codeblock{
	B2 = 3.7E-14\\
}

Not only can you assign floating point variables using scientific notation, but
the Commander X16 will also display values in scientific notation if they
require more than nine digits.\\

\subsection{Integer Variables}

\emph{Integer numeric variables} should be used whenever the number will always
be a whole number, and always be between $-32768$ and $32767$.  These are
numbers like $1$, $5$, or $-127$.  Integer variables take up less space in the
Commander X16's memory, and doing math with integers is faster than with
floating point numbers.  Integer numeric variables follow the same rules as
floating point variables, except they must have a {\ttfamily \%} character at
the end.  For example:\\

\codeblock{
	B\% = 5\\
	C5\% = -11\\
	BC\% = 1261\\
}

\note{

	Sometimes when writing numbers we place a {\ttfamily ,} to separate groups
	of three digits, such as $1,000$ or $8,006,029,545$.  While this makes
	numbers easier for humans to read, it is not something that Commander X16
	understands.  When typing numbers into your programs, you should never use
	a {\ttfamily ,} but instead type the numbers without it.  So the previous
	numbers would be typed as $1000$ and $8006029545$.\\

}

\subsection{String Variables}

\emph{String variables} are used to store characters, such as words, sentences,
or any other symbol that you can type.  A single string variable can store
either a single character, many characters in a row, or even no characters at
all!String variable names follow the same rules as floating point variables,
except they must have a {\ttfamily \$} character at the end.  The value of a
string variable must be enclosed in quotation marks.  For example:\\

\codeblock{
	N\$ = "COMMANDER X16"\\
	B8\$ = "SEVEN"\\
	DC\$ = "THE NEXT STRING HAS NO CHARACTERS IN IT"\\
	EC\$ = ""\\
}

\subsection{Arrays}

\emph{Arrays} are lists of variables that all share the same name.  You can
specify which item, or \emph{element}, in the list you are using by using a
number.  For example, if you have an array of floating point values in a
variable named {\ttfamily AB} you can use the second value in the array by
typing {\ttfamily AB(2)} where you would normally type a variable name or a
value.  You can create an array that holds any of the above types of variables,
but a single a array can only hold one type of variable.  So an array that was
created to hold seven strings can \emph{only} hold string variables, and will
cause an error if you try to assign an integer to one of the elements.\\

Unlike other variables, array variables usually\footnote{see the documentation
of the {\ttfamily DIM} statement for exceptions} need to be \emph{declared}
before using them.  You can declare your array variable with the {\ttfamily
DIM} statement like so:\\

\codeblock{
	DIM A(25)\\
}

This will tell the Commander X16 to reserve enough memory for twenty-five
floating point variables.  You can access these variables by \emph{indexing}
the array variable {\ttfamily A} when using it, like so:\\

\codeblock{
	PRINT A(14)\\
}

The above example prints the value of the fourteenth \emph{element} of
{\ttfamily A} to the screen.\\

Arrays can have more than one \emph{dimension} by declaring them with more than
one index.  For example a two-dimensional array can be useful for storing data
arranged as rows and columns.  Here is how you would declare an array with 24
rows of 32 columns:\\

\codeblock{
	DIM S\%(32,24)\\
}

The above array can store $32 \times 24$ integer values.  You could even
declare arrays with even higher dimensions if you have a need for it.  Be
warned, however, as higher dimensional arrays take up exponentially more memory
so you will quickly run out.\\

\section{Operators}

Commander X16 BASIC uses three different types of \emph{operators}:
\emph{arithmetic} operators, \emph{comparison} operators, and \emph{logical}
operators.

\subsection{Arithmetic Operators}

\emph{Arithmetic operators} are used for mathematical calculations.  Here are
the available arithmetic operators:\\

\begin{tabular}{l p{0.8\linewidth}}
	\ttfamily\bfseries{+}&addition\\
	\ttfamily\bfseries{-}&subtraction\\
	\ttfamily\bfseries{*}&multiplication\\
	\ttfamily\bfseries{/}&division\\
	\ttfamily\bfseries{↑}&raising to a power (exponentiation)\\
\end{tabular}

\vspace{16pt}

When several operators are used in the same arithmetic expression, there is an
\emph{order} in which the operations execute.  First, any exponentiation
operations execute.  Next, any multiplication or division operations execute.
Finally, any addition or subtraction operations execute.  When there are two or
more operations that execute at the same time, such as a multiplication
followed by a division, the operations execute from left to right.  Consider
the following:\\

\codeblock{
	PRINT 2/4/2\\
}

The above code will execute and print {\ttfamily .25} to the screen instead of
printing {\ttfamily 1}.  This is because {\ttfamily 2/4} executes first to
produce {\ttfamily .5}, and then {\ttfamily .5/2} executes to produce a final
value of {\ttfamily .25}.  If desired, you can force the order of operations by
enclosing calculations inside parentheses.  For example, we could reverse the
order of the operations above by typing:\\

\codeblock{
	PRINT 2/(4/2)\\
}

Now the result is {\ttfamily 1} because {\ttfamily 4/2} is executed first to
produce {\ttfamily 2}, and then {\ttfamily 2/2} executes to produce {\ttfamily
1}.

Using parentheses is a good practice even when not necessary, because it makes
the intention of the calculation obvious when reading the code.  Had we used
them in the original example, it would have made the execution obvious at first
glance:\\

\codeblock{
	PRINT (2/4)/2\\
}

The above code is identical to {\ttfamily 2/4/2}, but is easier to read.

\subsection{Comparison Operators}

\emph{Comparison operators} are useful for determining equalities and
inequalities.  These are used comparing values against each other to determine
if they are the same, not the same, or which is larger.  The comparison
operators are:\\

\begin{tabular}{l p{0.8\linewidth}}
	\ttfamily\bfseries{=}&is equal to\\
	\ttfamily\bfseries{<}&is less than\\
	\ttfamily\bfseries{>}&is greater than\\
	\ttfamily\bfseries{<= or =<}&is less than or equal to\\
	\ttfamily\bfseries{>= or =>}&is greater than or equal to\\
	\ttfamily\bfseries{<> or ><}&is not equal to\\
\end{tabular}

\vspace{16pt}

Comparison operators are most often used with {\ttfamily IF...THEN} statements.
For example:\\

\codeblock{
	A = 12\\
	IF A > 10 THEN PRINT "GREATER THAN 10"\\
}

As you can see from the code above, both variables and literal values can be
used with comparison operators.\\

\subsection{Logical Operators}

\emph{Logical operators} are used to join together multiple comparison
statements into a single statement.  There are three logical operators:\\

\begin{tabular}{l p{0.8\linewidth}}
	\ttfamily\bfseries{AND}&is true if both the left side and the right side are true\\
	\ttfamily\bfseries{OR}&is true if either the left side or the right side are true\\
	\ttfamily\bfseries{NOT}&is true if the right side is false\\
\end{tabular}

\vspace{16pt}

By using these logical operators, you can write complex conditions for your
programs.  Here's some examples:\\

\codeblock{
	IF A = B AND C = D THEN 100\\
	IF A = B OR NOT (C = D) THEN 100\\
}

Notice how parentheses can be used to explicitly force the order in which
logical conditions are evaluated, just like how they force the order in which
arithmetic is evaluated.\\

\section{Commands}

\emph{Commands} are instructions that you type in order to work with programs
on the Commander X16 or perform other user tasks.  Commands tell the Commander
X16 to do things, such as {\ttfamily LIST} the contents of the SD card,
{\ttfamily LOAD} a program from the SD card, or {\ttfamily RUN} the currently
loaded program.  This section contains a description of each command in
alhabetical order.\\

\subsection{BOOT}

The {\ttfamily BOOT} command loads and runs a PRG file named {\ttfamily
AUTOBOOT.X16} from device \#8 (the SD card reader). If the file is not found,
nothing is done and no error is printed.\\


\subsection{CLR}

The {\ttfamily CLR} command clears the BASIC variables from memory.  This
includes variables that were assigned values while running BASIC programs as
well as any BASIC assignments that were called from the {\ttfamily READY}
prompt directly.  Variables cleared with {\ttfamily CLR} cannot be restored
with the {\ttfamily OLD} command.

The {\ttfamily CLR} command runs automatically whenever the {\ttfamily RUN}
command is called, so that each run of a program starts with a cleared
variables state.  {\ttfamily CLR} is \emph{not} called when the {\ttfamily
CONT} command is run, so that a prgram can continue where it left off with the
variable state in tact.\\

\subsection{CLS}

The {\ttfamily CLS} command clears the screen. This has the same effect as
typing {\ttfamily PRINT CHR\$(147);} or typing
\keybackgroundcolor{gray}\keytextcolor{black}\widekey{shift}+\doublekey{clr\\home}.
This command is useful when programs and commands have cluttered up the screen,
and is also useful in BASIC programs to {\ttfamily PRINT}ing to an empty
screen.\\

\subsection{CONT (continue)}

When a program has been stopped by either using the
\keybackgroundcolor{gray}\doublekey{RUN\\STOP} key, a {\ttfamily STOP}
statement, or an {\ttfamily END} statement within the program, it can be
restarted by using the {\ttfamily CONT} command.  The {\ttfamily CONT} command
will continue executing the loaded program at the exact place from which it
left off, with all the variables intact.\\

The {\ttfamily CONT} command will not always work, however.  If you make any
modifications to your program while it is stopped, the {\ttfamily CONT} command
will fail and display a {\ttfamily CAN'T CONTINUE ERROR}.  This is true even if
you {\ttfamily LIST} the program and hit \widekey{RETURN} while the cursor is
on a line of the program...even if you didn't make any modifications.  To the
X16, this is still considered a change to the program, so the only way to run
it again is to start at the beginning of the program by using the {\ttfamily
RUN} command.\\

\subsection{DOS}

This command works with the command/status channel or the directory of a
Commodore DOS device and has different functionality depending on the type of
argument.\\

\begin{itemize}

	\item Without an argument, DOS prints the status string of the current device.

	\item With a string argument of {\ttfamily "8"} or {\ttfamily "9"}, it
		switches the current device to the given number.

	\item With an argument starting with {\ttfamily "\$"}, it shows the
		directory of the device.

	\item Any other argument will be sent as a DOS command.

\end{itemize}

\vspace{16pt}

Examples:\\

\codeblock{
	DOS"\$"          : REM SHOWS DIRECTORY\\
	DOS"S:BAD\_FILE" : REM DELETES "BAD\_FILE"\\
	DOS             : REM PRINTS DOS STATUS\\
}

\subsection{KEYMAP}

The {\ttfamily KEYMAP} command sets the current keyboard layout. It can be put
into an {\ttfamily AUTOBOOT.X16} file to always set the keyboard layout on
boot.\\

Example:\\

\codeblock{
	10 REM PROGRAM TO SET LAYOUT TO SWEDISH/SWEDEN\\
	20 KEYMAP "SV-SE"\\
	SAVE"AUTOBOOT.X16"  :REM SAVE AS AUTOBOOT FILE\\
}

\subsection{LIST}

The {\ttfamily LIST} command will print the currently loaded BASIC program to
the screen, either in its entirety or only the parts specified by the user.
When {\ttfamily LIST} is used without any numbers typed after it (known as
\emph{arguments}), you will see a complete listing of the program on your
screen.  If the program scrolls off the screen, and you are unable to see the
part that you want, you have a couple of options.  First, you can use the
\widekey{CTRL} key to slow down how fast lines are printed to the screen.  The
part you wish to see will still scroll off eventually, but you will be given a
much longer time to look at it.  Second, you can use the {\ttfamily LIST}
command with arguments that will limit the listing to only the line or lines
that you wish to see.  When you follow the {\ttfamily LIST} command with a
single number, the X16 will list only that line number (if it exists).  If you
follow {\ttfamily LIST} with two line numbers separated by a dash, the X16 will
list all the lines from the first number to the second (including both line
numbers).  If you follow {\ttfamily LIST} with a dash followed by a single
number, it lists from the beginning of the program up to and including the line
number.  Finally, if you follow {\ttfamily LIST} with a number followed by a
dash, it lists from the line number until the end of the program.\\

Examples:\\

\begin{tabular}{l p{0.8\linewidth}}
	{\ttfamily\bfseries LIST}&Shows entire program.\\\\
	{\ttfamily\bfseries LIST 10-}&Shows only from line 10 through the end.\\\\
	{\ttfamily\bfseries LIST 10}&Shows only line 10.\\\\
	{\ttfamily\bfseries LIST -10}&Shows from the beginning through line 10.\\\\
	{\ttfamily\bfseries LIST 10-20}&Shows lines from 10 through 20.\\\\
\end{tabular}

\vspace{16pt}

\subsection{LOAD}

The {\ttfamily LOAD} command is used when you want to use a program that is
stored on the Commander X16's SD card\footnote{the {\ttfamily LOAD} command can
also be used with other devices, but only the SD card reader ships with the
Commander X16}.  Typing {\ttfamily LOAD} and hitting \widekey{Return} will find
the first program on the SD card\footnote{The SD card uses the FAT32 disk
format, so it's a little complicated what makes a file considered the "first"}
and bring it into memory to be {\ttfamily RUN}, {\ttfamily LIST}ed, or edited.
You can also type {\ttfamily LOAD} followed by a name of a file in
quotes({\ttfamily ""}) to specify which file to load into memory.  The file
name argument may be followed by a comma and a numeric value which specifies a
device number.  If no number is given, the X16 uses device \#8, which is the SD
card reader.\\

Examples:\\

\begin{tabular}{l p{0.5\linewidth}}

	{\ttfamily\bfseries LOAD}&Loads the first program on the SD card into
	memory.\\\\

	{\ttfamily\bfseries LOAD "HELLO.PRG"}&Loads a program named {\ttfamily
	HELLO.PRG} from the SD card into memory.\\\\

	{\ttfamily\bfseries LOAD A\$}&Loads a program whose name is stored in the
	string variable {\ttfamily A\$} from the SD card into memory.\\\\

	{\ttfamily\bfseries LOAD "HELLO.PRG",1}&Loads a program named {\ttfamily
	HELLO.PRG} from the drive configured as device \#1.\\\\

\end{tabular}

\vspace{16pt}

There are also special file names that can be loaded that perform specific
tasks when used with {\ttfamily LOAD}:\\

\begin{tabular}{l p{0.75\linewidth}}

	{\ttfamily\bfseries LOAD "*",8}&Loads the first program on device \#8 into
	memory.\\\\

	{\ttfamily\bfseries LOAD "\$"}&Loads a directory listing of the SD card
	into memory which can be displayed with {\ttfamily LIST}.\\\\

\end{tabular}

\vspace{16pt}

The {\ttfamily LOAD} command can be used with a BASIC program to load and
{\ttfamily RUN} another program.\\

\subsection{MON}

The {\ttfamily MON} command causes the Commander X16 to enter the machine
language monitor.\\

\subsection{NEW} 

The {\ttfamily NEW} command marks the current program and its variables as
erased, but leaves them in memory.  This behavior is so that both the program
and its variables can be restored with the {\ttfamily OLD} command.  The effect
is that the Commander X16 is ready for a new program.\\

\subsection{OLD}

 The {\ttfamily OLD} command recovers the BASIC program in RAM that has been
 previously marked erased either by using the {\ttfamily NEW} command, by
 pressing the reset button on the case, or by pressing the
 \keybackgroundcolor{gray}\keytextcolor{black}\widekey{ctrl}+\widekey{alt}+\widekey{del}
 key combination on the keyboard.\\

\subsection{RESET}

The {\ttfamily RESET} command performs a full system reset, but does not clear
memory.  This means that a BASIC program and its variables can be restored
after a {\ttfamily RESET} by using the {\ttfamily OLD} command.\\

\note{

	There are multiple ways to reset a Commander X16, and each produces a
	slightly different result.\\

	The first is by using the
	\keybackgroundcolor{gray}\keytextcolor{black}\widekey{ctrl}+\widekey{alt}+\widekey{restore}
	key combination.  This halts the execution of any program, clears the
	screen, and returns the user to the {\ttfamily READY} prompt.  It does not
	mark a program or its variables as erased, and so a program can be
	{\ttfamily RUN} again or {\ttfamily CONT}inued if desired.\\

	The second is by pressing the physical reset button on the case.  This has
	the same result as the {\ttfamily RESET} command.\\

	The third is a cold reboot, where the power to the Commander X16 is lost
	and then restored.  This causes the current program and its variables are
	completely lost and cannot be restored with the {\ttfamily OLD} command.
}

\subsection{RUN}

The {\ttfamily RUN} command executes the program currently loaded into memory.
This program could have been typed in, or it could have been loaded from the SD
card with the {\ttfamily LOAD} command.  When called, the {\ttfamily RUN}
command will clear the BASIC variables (just like calling the {\ttfamily CLR}
command) and begin running the program.  When no number follows the {\ttfamily
RUN} command, the program will start executing from the lowest line number in
the program.  Otherwise, {\ttfamily RUN} will start executing at the given line
number, or the next lowest line number in the program.\\

Examples:\\

\begin{tabular}{l p{0.75\linewidth}}

	{\ttfamily\bfseries RUN}&Starts program from lowest line number.\\\\

	{\ttfamily\bfseries RUN 50}&Starts program at line 50.\\\\

	{\ttfamily\bfseries RUN A}&UNDEFINED ERROR ({\ttfamily RUN} cannot be used
	with a variable to specify a line number).\\\\

\end{tabular}

\subsection{SAVE}

The {\ttfamily SAVE} command will store the the current program in memory to
the SD card or another storage device.  The {\ttfamily SAVE} command should be
followed either by a file name in quotation marks, or a string variable that
contains the desired file name\footnote{calling the {\ttfamily SAVE} command
without any arguments is technically allowed, but doesn't do anything.  On the
Commodore VIC-20 and Commodore 64 this was useful for saving the current
program to the current position of a tape drive with no name, but the Commander
X16's default device is an SD card reader where this concept makes no sense.
For historical reasons, the Commander X16 won't display an error if you run
{\ttfamily SAVE} with no arguments, but it also won't do anything}.  The file
name argument can be followed by a comma and a number or numeric variable.
This number tells the Commander X16 which device to store the file on.  Device
number 8 is the SD card drive and is used if no number is given.\\

If a tape dirve is used with the Commander X16, then a second numeric argument
of either {\ttfamily 0} or {\ttfamily 1} can be specified after the device
number.  If this second is a {\ttfamily 1}, an {\ttfamily END-OF-TAPE} marker
will be written after the program.  If you are attempting to {\ttfamily LOAD} a
program off a tape drive and this marker is read before finding the desired
file, a {\ttfamily FILE NOT FOUND ERROR} will be displayed.\\

Examples:\\

\begin{tabular}{l p{0.5\linewidth}}

	{\ttfamily\bfseries SAVE "HELLO.PRG"}&Saves the program in memory to a file
	on the SD card with the name {\ttfamily HELLO.PRG}.\\\\

	{\ttfamily\bfseries SAVE A\$}&Saves the program in memory to a file on the
	SD card the name contained in the variable{\ttfamily A\$}.\\\\

	{\ttfamily\bfseries SAVE "HELLO.PRG",1}&Saves the program in memory to a
	file on the drive configured as device \#1 with the name {\ttfamily
	HELLO.PRG}.\\\\

	{\ttfamily\bfseries SAVE "HELLO.PRG",1,1}&Saves the program in memory to a
	file on the drive configured as device \#1 with the name {\ttfamily
	HELLO.PRG} and writes an {\ttfamily END-OF-TAPE} marker after it.\\\\

\end{tabular}

\subsection{VERIFY}

The {\ttfamily VERIFY} command will compare the program in memory to a program
on the SD card or other storage device.  If the programs are the same, the
{\ttfamily VERIFY} command will display an {\ttfamily OK} message, and if they
differ it will display a {\ttfamily VERIFY ERROR} message.  This command helps
to ensure that a program is safely stored to the SD card or other storage
device before the user erases it from memory\footnote{this was far more useful
in the era or tape drives and floppy disks than it is on the Commander X16}.
When {\ttfamily VERIFY} is called without any arguments, it checks the program
in memory against the first file on the SD card\footnote{this is not
particularly useful, but is included behavior for historical reasons}.  When
called followed by a file name in quotation marks or a string variable
containing a file name, it compares the program in memory against the given
file.  Just like the {\ttfamily LOAD} and {\ttfamily SAVE} commands, the
{\ttfamily VERIFY} command can take a numeric second argument as a device
number.\\

% easter egg hidden here as a tribute to a VIC-20 User's Guide printing error
% https://cdn.discordapp.com/attachments/629903630916648962/1075543304680263710/20230215_162450.jpg
The {\ttfamily VERIFY} command can also be used if a tape drive is connected to
the Commander X16 as a storage device.  By {\ttfamily VERIFY}ing the last
program on the taþe, the position of the tape can be advanced to a safe section
to write over.  When {\ttfamily VERIFY} is complete, whether verification
succeeds or fails, the tape will be positioned at the next available space.\\

Examples:\\

\begin{tabular}{l p{0.5\linewidth}}

	{\ttfamily\bfseries VERIFY}&Checks the first program on the SD card.\\\\

	{\ttfamily\bfseries VERIFY A\$}&Checks the program with name in variable
	{\ttfamily A\$}.\\\\

	{\ttfamily\bfseries VERIFY "HELLO.PRG",1}&Checks the program on the drive
	configured as device \#1 with the name {\ttfamily HELLO.PRG}.\\\\

\end{tabular}

\section{Statements}

\emph{Statements} are the instructions used in BASIC on numbered lines of
programs.  They are used to define what it is that your program does.\\

\subsection{BANK}

The {\ttfamily BANK} statement sets which bank will be used when other commands
and statements interpret addresses in the \$A000 - \$FFFF range.  Because all
addresses from \$A000 and above are either banked "high" RAM or banked ROM,
certain commands need to know \emph{which} bank is being referred to.
Specifically, {\ttfamily SYS}, {\ttfamily POKE}, and {\ttfamily PEEK} all need
to know which bank to use when an address in the banked range is referred to.
The {\ttfamily BANK} statement sets the bank for both banked
RAM\footnote{RAM in bank 0 is reserved for use by the KERNAL, so it is
unwise to write values into there} and banked ROM.  To set a bank, call the
{\ttfamily BANK} statement followed by a numeric value from 0 through 255.\\

For example, to write some data into "high" RAM in bank 1:

\codeblock{
	10 BANK 1\\
	20 POKE \$A000,42
}

Then the bank can be switched, and the same address can be used to store more
data, without overwriting the data in bank 1:

\codeblock{
	30 BANK 2\\
	40 POKE \$A000,23\\
	50 BANK 1				REM SWITCH BACK TO BANK 1\\
	60 PRINT PEEK(\$A000)	REM PRINTS 42, NOT 23\\
}

The {\ttfamily BANK} statement also has some use as a command run from the
{\ttfamily READY} prompt.  It can be used to run programs that are shipped with
the Commander X16 in banked ROM.  For example, the CodeX16 Interactive Assembly
Environment in ROM bank 7 can by run by typing the following at the {\ttfamily
READY} prompt:\\

\codeblock{
	BANK 7\\
	SYS \$C000\\
}

\subsection{BLOAD}

The {\ttfamily BLOAD} statement loads a headerless\footnote{typically on
Commodore computers as well as the X16, files are expected to contain a
two-byte header that indicates an address where they are to be loaded into
memory.  A "headerless" file will not have those two bytes} file from a device
into banked RAM.  If the file is too large to fit within a bank, the {\ttfamily
BLOAD} statement will automatically continue writing the file to the next bank.
This allows file resources larger than 8 kilobytes to be used without the need
to break them up into smaller files.  This is useful for loading resources for
games and applications into "high" RAM that programs can then access during
execution.\\

Examples:\\

\begin{tabular}{l p{0.4\linewidth}}

	{\ttfamily\bfseries BLOAD "MYFILE.BIN",8,1,\$A000}&Loads a file named
	"MYFILE.BIN" from device 8 starting in bank 1 at \$A000.\\\\

	{\ttfamily\bfseries BLOAD "WHO.PCX",8,10,\$B000}&Loads a file named
	"WHO.PCX" from device 8 starting in bank 10 at \$B000.\\\\

\end{tabular}

\subsection{BVERIFY}

The {\ttfamily BVERIFY} statement compares a headerless file on the SD card or
other storage device to the contents of banked RAM.  As arguments, the
{\ttfamily BVERIFY} statement takes the name of the file, the device number,
the bank number, and the starting address within the bank.  If the file in
question extends past the end of the bank, the {\ttfamily BVERIFY} statement
will automatically continue checking on the file on the next bank, resetting
the address to {\ttfamily \$A000} as it changes the bank.  This allows it to be
used to verify files that are too large to fit inside a single bank of "high"
RAM.\\

Examples:\\

\begin{tabular}{l p{0.35\linewidth}}

	{\ttfamily\bfseries BVERIFY "MYFILE.BIN",8,1,\$A000}&Compares a file named
	"MYFILE.BIN" from device 8 against the RAM in bank 1 starting at
	\$A000.\\\\

	{\ttfamily\bfseries BVERIFY "WHO.PCX",8,10,\$B000}&Compares a file named
	"WHO.PCX" from device 8 against the RAM in bank 10 starting at \$B000.\\\\

\end{tabular}

\subsection{BVLOAD}

The {\ttfamily BVLOAD} statement loads a headerless file directly into the
VERA's VRAM.  For arguments, the {\ttfamily BVLOAD} statement takes the file's
name, the device number where the file is stored, the bank of VRAM on the VERA
(either {\ttfamily 0} or {\ttfamily 1}), and the address within the bank in
which to load.\\

Examples:\\

\begin{tabular}{l p{0.35\linewidth}}

	{\ttfamily\bfseries BVLOAD "MYFILE.BIN",8,0,\$4000}&Loads a file named
	"MYFILE.BIN" from device 8 into VRAM at address \$04000.\\\\

	{\ttfamily\bfseries BVLOAD "MYFONT.BIN",8,1,\$F000}&Loads a file named
	"MYFONT.BIN" from device 8 into VRAM at address \$1F000.\\\\

\end{tabular}

\subsection{CHAR}

This statement draws a text string on the graphics screen in a given color.
The string can contain printable ASCII characters ({\ttfamily CHR\$(\$20)} to
{\ttfamily CHR\$(\$7E)}), as well most PETSCII control codes.\\

\subsection{CLOSE}

<TODO>

\subsection{CMD}

<TODO>

\subsection{COLOR}

This command works sets the text mode foreground color, and optionally the
background color.\\

\subsection{DATA}

<TODO>

\subsection{DEF}

<TODO>

\subsection{DIM}

<TODO>

\subsection{END}

<TODO>

\subsection{FMCHORD}

<TODO>

\subsection{FMDRUM}

<TODO>

\subsection{FMFREQ}

<TODO>

\subsection{FMINIT}

<TODO>

\subsection{FMINST}

<TODO>

\subsection{FMNOTE}

<TODO>

\subsection{FMPAN}

<TODO>

\subsection{FMPLAY}

<TODO>

\subsection{FMPOKE}

<TODO>

\subsection{FMVIB}

<TODO>

\subsection{FMVOL}

<TODO>

\subsection{FOR}

<TODO>

\subsection{FRAME}

This command draws a rectangle frame on the graphics screen in a given color.\\

\subsection{GEOS}

<TODO>

\subsection{GET}

<TODO>

\subsection{GET\#}

<TODO>

\subsection{GOSUB}

<TODO>

\subsection{GOTO}

<TODO>

\subsection{IF}

<TODO>

\subsection{INPUT}

<TODO>

\subsection{INPUT\#}

<TODO>

\subsection{LET}

<TODO>

\subsection{LINE}

<TODO>

\subsection{LOCATE}

<TODO>

\subsection{MOUSE}

<TODO>

\subsection{NEXT}

<TODO>

\subsection{ON}

<TODO>

\subsection{OPEN}

<TODO>

\subsection{POKE}

<TODO>

\subsection{PRINT}

<TODO>

\subsection{PRINT\#}

<TODO>

\subsection{PSET}

<TODO>

\subsection{PSET}

<TODO>

\subsection{PSGCHORD}

<TODO>

\subsection{PSGFREQ}

<TODO>

\subsection{PSGINIT}

<TODO>

\subsection{PSGNOTE}

<TODO>

\subsection{PSGPAN}

<TODO>

\subsection{PSGPLAY}

<TODO>

\subsection{PSGVOL}

<TODO>

\subsection{PSGWAV}

<TODO>

\subsection{READ}

<TODO>

\subsection{RECT}

<TODO>

\subsection{REM}

<TODO>

\subsection{REM}

<TODO>

\subsection{RESTORE}

<TODO>

\subsection{RETURN}

<TODO>

\subsection{SCREEN}

<TODO>

\subsection{STEP}

<TODO>

\subsection{STOP}

<TODO>

\subsection{SYS}

<TODO>

\subsection{THEN}

<TODO>

\subsection{TO}

<TODO>

\subsection{VPOKE}

<TODO>

\subsection{VLOAD}

<TODO>

\subsection{WAIT}

<TODO>

\section{Functions}

\subsection{ABS}

<TODO>

\subsection{ASC}

<TODO>

\subsection{ATN}

<TODO>

\subsection{BIN\$}

<TODO>

\subsection{CHR\$}

<TODO>

\subsection{COS}

<TODO>

\subsection{EXP}

<TODO>

\subsection{FN}

<TODO>

\subsection{FRE}

<TODO>

\subsection{HEX\$}

<TODO>

\subsection{INT}

<TODO>

\subsection{LEFT\$}

<TODO>

\subsection{LEN}

<TODO>

\subsection{LOG}

<TODO>

\subsection{MID\$}

<TODO>

\subsection{PEEK}

<TODO>

\subsection{\ttfamily π}

<TODO>

\subsection{POS}

<TODO>

\subsection{RIGHT\$}

<TODO>

\subsection{RND}

<TODO>

\subsection{RND}

<TODO>

\subsection{SGN}

<TODO>

\subsection{SIN}

<TODO>

\subsection{SPC}

<TODO>

\subsection{SQR}

<TODO>

\subsection{STR\$}

<TODO>

\subsection{TAB}

<TODO>

\subsection{TAN}

<TODO>

\subsection{USR}

<TODO>

\subsection{VAL}

<TODO>

\subsection{VPEEK}

<TODO>

